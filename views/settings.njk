<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("Game Settings Manager") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/settings.css">
    <script type="module" src="/vendor/vaadin.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öôÔ∏è Game Settings Manager</h1>
            <p>Create and manage custom game world settings</p>
            {% include "_navigation.njk" %}
        </div>

        <div id="statusMessage" class="status-message"></div>

        <div class="settings-grid">
            <!-- Settings List Panel -->
            <div class="settings-list">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h2>üìã Saved Settings</h2>
                    <div style="display: flex; gap: 0.5rem;">
                        <button id="loadBtn" class="btn-small btn-secondary">Load</button>
                        <button id="saveAllBtn" class="btn-small btn-primary">Save All</button>
                    </div>
                </div>
                
                <div id="settingsList">
                    <div class="empty-state">
                        <p>No settings created yet.<br>Create your first setting using the form ‚Üí</p>
                    </div>
                </div>
            </div>

            <!-- Settings Form Panel -->
            <div class="settings-form">
                <h2 id="formTitle">‚ú® Create New Setting</h2>
                
                <form id="settingForm">
                    <input type="hidden" id="settingId" name="id">

                    <div class="form-group">
                        <label for="name">Setting Name *</label>
                        <input type="text" id="name" name="name" required>
                        <div class="help-text">Unique name for this setting configuration</div>
                    </div>

                    <div class="form-group">
                        <label for="description">Description</label>
                        <textarea id="description" name="description" placeholder="Describe this setting and what makes it unique..."></textarea>
                    </div>

                    <div class="form-group">
                        <label for="theme">World Theme *</label>
                        <vaadin-combo-box id="theme" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">The overarching setting of the game world</div>
                    </div>

                    <div class="form-group">
                        <label for="genre">Game Genre *</label>
                        <vaadin-combo-box id="genre" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">Primary style of gameplay focus</div>
                    </div>

                    <div class="form-group">
                        <label for="startingLocationType">Starting Location Type</label>
                        <vaadin-combo-box id="startingLocationType" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">Where adventures typically begin</div>
                    </div>

                    <div class="form-group">
                        <label for="magicLevel">Magic Level</label>
                        <vaadin-combo-box id="magicLevel" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">How common magic is in the world</div>
                    </div>

                    <div class="form-group">
                        <label for="techLevel">Technology Level</label>
                        <vaadin-combo-box id="techLevel" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">Technological advancement of the world</div>
                    </div>

                    <div class="form-group">
                        <label for="tone">Narrative Tone</label>
                        <vaadin-combo-box id="tone" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">Overall emotional atmosphere</div>
                    </div>

                    <div class="form-group">
                        <label for="difficulty">Difficulty Level</label>
                        <vaadin-combo-box id="difficulty" allow-custom-value></vaadin-combo-box>
                        <div class="help-text">Challenge level and lethality</div>
                    </div>

                    <div class="form-group">
                        <label for="playerStartingLevel">Player Starting Level</label>
                        <input type="number" id="playerStartingLevel" name="playerStartingLevel" min="1" max="20" value="1">
                        <div class="help-text">Level for new players (1-20)</div>
                    </div>

                    <!-- Preview Section -->
                    <div id="previewSection" class="preview-section" style="display: none;">
                        <div class="preview-title">Setting Preview</div>
                        <div id="previewContent"></div>
                    </div>

                    <div class="form-actions">
                        <div class="button-group">
                            <button type="button" id="clearBtn" class="btn btn-secondary">Clear</button>
                            <button type="submit" id="submitBtn" class="btn btn-primary">Create Setting</button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        let currentSettings = [];
        let selectedSettingId = null;
        let isEditMode = false;
        let definitions = null;
        let appliedSetting = null;

        // Load definitions and settings on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadDefinitions();
            await refreshSettingsList();
            await loadCurrentSetting();
            setupEventListeners();
        });

        async function loadDefinitions() {
            try {
                const response = await fetch('/api/settings/definitions');
                const data = await response.json();
                
                if (data.success) {
                    definitions = data;
                    populateSelectOptions();
                }
            } catch (error) {
                showMessage('Error loading setting definitions: ' + error.message, 'error');
            }
        }

        function populateSelectOptions() {
            if (!definitions) return;

            const selects = {
                theme: document.getElementById('theme'),
                genre: document.getElementById('genre'),
                startingLocationType: document.getElementById('startingLocationType'),
                magicLevel: document.getElementById('magicLevel'),
                techLevel: document.getElementById('techLevel'),
                tone: document.getElementById('tone'),
                difficulty: document.getElementById('difficulty')
            };

            // Populate each select with options
            Object.keys(selects).forEach(key => {
                const select = selects[key];
                const options = definitions.definitions[key] || [];
                const defaultValue = definitions.defaults[key];

                // Clear existing options except the first one
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option.charAt(0).toUpperCase() + option.slice(1).replace(/-/g, ' ');
                    if (option === defaultValue) {
                        optionElement.selected = true;
                    }
                    select.appendChild(optionElement);
                });

                // Add "Other..." option for fields with select-with-other
                if (select.closest('.select-with-other')) {
                    const otherOption = document.createElement('option');
                    otherOption.value = 'OTHER';
                    otherOption.textContent = 'Other...';
                    select.appendChild(otherOption);
                }
            });

            // Setup select-with-other functionality
            setupSelectWithOther();
        }

        function setupSelectWithOther() {
            document.querySelectorAll('.select-with-other').forEach(container => {
                const select = container.querySelector('select');
                const otherInput = container.querySelector('.other-input');
                const fieldName = container.dataset.field;

                select.addEventListener('change', function() {
                    if (this.value === 'OTHER') {
                        otherInput.style.display = 'block';
                        otherInput.required = select.required;
                        otherInput.focus();
                        // Set a temporary value to satisfy form validation
                        otherInput.value = otherInput.value || '';
                    } else {
                        otherInput.style.display = 'none';
                        otherInput.required = false;
                        otherInput.value = '';
                    }
                });

                // Handle other input changes
                otherInput.addEventListener('input', function() {
                    if (select.value === 'OTHER' && this.value.trim()) {
                        // Create hidden input to hold the actual value
                        let hiddenInput = container.querySelector('.other-value');
                        if (!hiddenInput) {
                            hiddenInput = document.createElement('input');
                            hiddenInput.type = 'hidden';
                            hiddenInput.className = 'other-value';
                            hiddenInput.name = fieldName + '_other';
                            container.appendChild(hiddenInput);
                        }
                        hiddenInput.value = this.value.trim();
                    }
                });
            });
        }

        function getFormValue(fieldName) {
            const container = document.querySelector(`[data-field="${fieldName}"]`);
            if (container) {
                const select = container.querySelector('select');
                const otherInput = container.querySelector('.other-input');
                
                if (select.value === 'OTHER' && otherInput.value.trim()) {
                    return otherInput.value.trim();
                } else if (select.value && select.value !== 'OTHER') {
                    return select.value;
                }
                return '';
            }
            
            // Fallback for regular fields
            const element = document.getElementById(fieldName);
            return element ? element.value : '';
        }

        function setFormValue(fieldName, value) {
            const container = document.querySelector(`[data-field="${fieldName}"]`);
            if (container) {
                const select = container.querySelector('select');
                const otherInput = container.querySelector('.other-input');
                
                // Check if value exists in select options
                const option = Array.from(select.options).find(opt => opt.value === value);
                
                if (option && value !== 'OTHER') {
                    select.value = value;
                    otherInput.style.display = 'none';
                    otherInput.required = false;
                    otherInput.value = '';
                } else if (value) {
                    // Custom value - use "Other" option
                    select.value = 'OTHER';
                    otherInput.style.display = 'block';
                    otherInput.required = select.required;
                    otherInput.value = value;
                }
            } else {
                // Fallback for regular fields
                const element = document.getElementById(fieldName);
                if (element) element.value = value;
            }
        }

        async function refreshSettingsList() {
            try {
                const response = await fetch('/api/settings');
                const data = await response.json();
                
                if (data.success) {
                    currentSettings = data.settings;
                    renderSettingsList();
                }
            } catch (error) {
                showMessage('Error loading settings: ' + error.message, 'error');
            }
        }

        async function loadCurrentSetting() {
            try {
                const response = await fetch('/api/settings/current');
                const data = await response.json();
                
                if (data.success && data.setting) {
                    appliedSetting = data.setting;
                    updateCurrentSettingDisplay();
                }
            } catch (error) {
                console.warn('Could not load current setting:', error.message);
            }
        }

        function updateCurrentSettingDisplay() {
            const listHeader = document.querySelector('.settings-list h2');
            if (appliedSetting) {
                listHeader.innerHTML = `üìã Saved Settings <small style="color: #4CAF50;">(${appliedSetting.name} applied)</small>`;
            } else {
                listHeader.innerHTML = 'üìã Saved Settings';
            }
        }

        function renderSettingsList() {
            const container = document.getElementById('settingsList');
            
            if (currentSettings.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>No settings created yet.<br>Create your first setting using the form ‚Üí</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = currentSettings.map(setting => `
                <div class="setting-item ${selectedSettingId === setting.id ? 'selected' : ''} ${appliedSetting && appliedSetting.id === setting.id ? 'applied' : ''}" 
                     onclick="selectSetting('${setting.id}')">
                    <div class="setting-header">
                        <div class="setting-name">
                            ${setting.name}
                            ${appliedSetting && appliedSetting.id === setting.id ? ' <span style="color: #4CAF50;">‚úì Applied</span>' : ''}
                        </div>
                    </div>
                    <div class="setting-meta">
                        ${setting.theme}/${setting.genre} ‚Ä¢ ${setting.tone} ‚Ä¢ ${setting.difficulty}
                    </div>
                    <div class="setting-actions">
                        <button class="btn-small btn-edit" onclick="editSetting('${setting.id}'); event.stopPropagation();">Edit</button>
                        <button class="btn-small btn-primary" onclick="applySetting('${setting.id}'); event.stopPropagation();">Apply</button>
                        <button class="btn-small btn-clone" onclick="cloneSetting('${setting.id}'); event.stopPropagation();">Clone</button>
                        <button class="btn-small btn-delete" onclick="deleteSetting('${setting.id}'); event.stopPropagation();">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function selectSetting(settingId) {
            selectedSettingId = settingId;
            renderSettingsList();
            updatePreview();
        }

        function editSetting(settingId) {
            const setting = currentSettings.find(s => s.id === settingId);
            if (!setting) return;

            isEditMode = true;
            selectedSettingId = settingId;
            
            // Populate form with setting data
            document.getElementById('settingId').value = setting.id;
            document.getElementById('name').value = setting.name;
            document.getElementById('description').value = setting.description || '';
            setFormValue('theme', setting.theme);
            setFormValue('genre', setting.genre);
            document.getElementById('startingLocationType').value = setting.startingLocationType;
            document.getElementById('magicLevel').value = setting.magicLevel;
            document.getElementById('techLevel').value = setting.techLevel;
            document.getElementById('tone').value = setting.tone;
            document.getElementById('difficulty').value = setting.difficulty;
            document.getElementById('playerStartingLevel').value = setting.playerStartingLevel;

            // Update form title and button
            document.getElementById('formTitle').textContent = `‚úèÔ∏è Edit Setting: ${setting.name}`;
            document.getElementById('submitBtn').textContent = 'Update Setting';
            
            renderSettingsList();
            updatePreview();
        }

        async function cloneSetting(settingId) {
            try {
                const newName = prompt('Enter name for cloned setting:');
                if (!newName) return;

                const response = await fetch(`/api/settings/${settingId}/clone`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newName })
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage('Setting cloned successfully!', 'success');
                    await refreshSettingsList();
                } else {
                    showMessage('Error cloning setting: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('Error cloning setting: ' + error.message, 'error');
            }
        }

        async function deleteSetting(settingId) {
            if (!confirm('Are you sure you want to delete this setting?')) return;

            try {
                const response = await fetch(`/api/settings/${settingId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage('Setting deleted successfully!', 'success');
                    
                    // Clear form if we were editing this setting
                    if (selectedSettingId === settingId) {
                        clearForm();
                    }
                    
                    await refreshSettingsList();
                } else {
                    showMessage('Error deleting setting: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('Error deleting setting: ' + error.message, 'error');
            }
        }

        async function applySetting(settingId) {
            try {
                const response = await fetch(`/api/settings/${settingId}/apply`, {
                    method: 'POST'
                });

                const data = await response.json();
                
                if (data.success) {
                    showMessage('Setting applied successfully! Game Master will now use this setting.', 'success');
                    appliedSetting = data.setting;
                    updateCurrentSettingDisplay();
                    renderSettingsList();
                } else {
                    showMessage('Error applying setting: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('Error applying setting: ' + error.message, 'error');
            }
        }

        function clearForm() {
            document.getElementById('settingForm').reset();
            document.getElementById('settingId').value = '';
            document.getElementById('formTitle').textContent = '‚ú® Create New Setting';
            document.getElementById('submitBtn').textContent = 'Create Setting';
            
            isEditMode = false;
            selectedSettingId = null;
            
            // Reset to defaults
            if (definitions) {
                Object.keys(definitions.defaults).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = definitions.defaults[key];
                    }
                });
            }
            
            document.getElementById('playerStartingLevel').value = '1';
            renderSettingsList();
            updatePreview();
        }

        function updatePreview() {
            const form = document.getElementById('settingForm');
            const formData = new FormData(form);
            
            const preview = document.getElementById('previewSection');
            const content = document.getElementById('previewContent');
            
            const name = formData.get('name');
            if (!name) {
                preview.style.display = 'none';
                return;
            }
            
            preview.style.display = 'block';
            
            const theme = formData.get('theme') || 'Not set';
            const genre = formData.get('genre') || 'Not set';
            const tone = formData.get('tone') || 'Not set';
            const difficulty = formData.get('difficulty') || 'Not set';
            const magicLevel = formData.get('magicLevel') || 'Not set';
            const techLevel = formData.get('techLevel') || 'Not set';
            
            content.innerHTML = `
                <strong>${name}</strong><br>
                <small>${theme}/${genre} setting with ${tone} tone and ${difficulty} difficulty</small><br>
                Magic: ${magicLevel} ‚Ä¢ Tech: ${techLevel}
            `;
        }

        function setupEventListeners() {
            // Form submission
            document.getElementById('settingForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const formData = new FormData(e.target);
                const settingData = Object.fromEntries(formData.entries());
                
                // Handle select-with-other fields
                settingData.theme = getFormValue('theme');
                settingData.genre = getFormValue('genre');
                
                // Convert playerStartingLevel to number
                settingData.playerStartingLevel = parseInt(settingData.playerStartingLevel) || 1;
                
                try {
                    let response;
                    if (isEditMode) {
                        const settingId = settingData.id;
                        delete settingData.id;
                        response = await fetch(`/api/settings/${settingId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settingData)
                        });
                    } else {
                        response = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settingData)
                        });
                    }

                    const data = await response.json();
                    
                    if (data.success) {
                        showMessage(`Setting ${isEditMode ? 'updated' : 'created'} successfully!`, 'success');
                        clearForm();
                        await refreshSettingsList();
                    } else {
                        showMessage(`Error ${isEditMode ? 'updating' : 'creating'} setting: ` + data.error, 'error');
                    }
                } catch (error) {
                    showMessage(`Error ${isEditMode ? 'updating' : 'creating'} setting: ` + error.message, 'error');
                }
            });

            // Clear button
            document.getElementById('clearBtn').addEventListener('click', clearForm);

            // Form change detection for preview
            document.getElementById('settingForm').addEventListener('input', updatePreview);
            document.getElementById('settingForm').addEventListener('change', updatePreview);

            // Save all button
            document.getElementById('saveAllBtn').addEventListener('click', async function() {
                try {
                    const response = await fetch('/api/settings/save', {
                        method: 'POST'
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showMessage(`Saved ${data.result.count} settings to files!`, 'success');
                    } else {
                        showMessage('Error saving settings: ' + data.error, 'error');
                    }
                } catch (error) {
                    showMessage('Error saving settings: ' + error.message, 'error');
                }
            });

            // Load button
            document.getElementById('loadBtn').addEventListener('click', async function() {
                if (!confirm('This will replace current settings with saved files. Continue?')) return;
                
                try {
                    const response = await fetch('/api/settings/load', {
                        method: 'POST'
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showMessage(`Loaded ${data.result.count} settings from files!`, 'success');
                        clearForm();
                        await refreshSettingsList();
                    } else {
                        showMessage('Error loading settings: ' + data.error, 'error');
                    }
                } catch (error) {
                    showMessage('Error loading settings: ' + error.message, 'error');
                }
            });
        }

        function showMessage(message, type) {
            const messageEl = document.getElementById('statusMessage');
            messageEl.textContent = message;
            messageEl.className = `status-message status-${type}`;
            messageEl.style.display = 'block';
            
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>