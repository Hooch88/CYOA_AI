<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("AI RPG Chat") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/map.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI RPG Chat Interface ü§ñ</h1>
            {% include "_navigation.njk" %}
        </div>
        
        <div class="main-content">
            <div class="tab-bar" role="tablist">
                <button class="tab-button active" id="tab-adventure-tab" data-tab="adventure" role="tab" aria-selected="true" aria-controls="tab-adventure">Adventure</button>
                <button class="tab-button" id="tab-map-tab" data-tab="map" role="tab" aria-selected="false" aria-controls="tab-map">Map</button>
            </div>

            <div class="tab-panels">
                <section class="tab-panel active" id="tab-adventure" role="tabpanel" aria-labelledby="tab-adventure-tab">
                    <div class="adventure-content">
                        <div class="location-block">
                            <div class="container">
                                <div class="location-header">
                                    <h4>üìç <span class="location-name" id="locationName">Unknown Location</span></h4>
                                </div>
                                <div class="location-content" id="locationContent">
                                    <div class="location-image" id="locationImage">
                                        <div class="location-placeholder">
                                            <!-- Nothing in here on initial load -->
                                        </div>
                                        <div class="location-tooltip" id="locationTooltip">Your current location will appear here when you start exploring.</div>
                                    </div>
                                    <div class="location-info" id="locationInfo">
                                        <div class="location-details" id="locationDetails">
                                            <span class="location-level" id="locationLevel">Level: ?</span>
                                        </div>
                                        <div class="location-hint" id="locationHint">Hover over the location image for a description.</div>
                                        <div class="location-exits" id="locationExits">
                                            <div class="no-exits">No exits discovered yet.</div>
                                        </div>
                                        <div class="location-npcs" id="locationNPCs">
                                            <div class="location-npc-empty">No notable NPCs present.</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="chat-container">
                            <div class="chat-log" id="chatLog">
                                {% if chatHistory and chatHistory.length > 0 %}
                                    {% for message in chatHistory %}
                                        <div class="message {{ 'user-message' if message.role == 'user' else 'ai-message' }}">
                                            <div class="message-sender">
                                                {% if message.role == 'user' %}
                                                    üë§ You
                                                {% else %}
                                                    ü§ñ AI Game Master
                                                {% endif %}
                                            </div>
                                            <div>{{ message.content }}</div>
                                            <div class="message-timestamp">{{ message.timestamp | replace('T', ' ') | replace('Z', '') }}</div>
                                        </div>
                                    {% endfor %}
                                {% else %}
                                    <div class="message ai-message">
                                        <div class="message-sender">ü§ñ AI Game Master</div>
                                        <div>Welcome to the AI RPG! I'm your Game Master. Configure your AI settings above and then describe what kind of adventure you'd like to embark on.</div>
                                    </div>
                                {% endif %}
                            </div>
                            
                            <div class="input-area">
                                <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
                                <button class="send-button" id="sendButton">Send</button>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="tab-panel" id="tab-map" role="tabpanel" aria-labelledby="tab-map-tab" hidden>
                    <div id="mapContainer" class="map-placeholder"></div>
                </section>
            </div>
        </div>
    </div>

    <div id="locationOverlay" class="overlay-backdrop" aria-live="polite" aria-busy="false" aria-label="Loading location">
        <div class="overlay-content">
            <div class="spinner" role="status" aria-hidden="true"></div>
            <div class="overlay-text" id="locationOverlayText">Exploring...</div>
        </div>
    </div>

    <script src="/vendor/cytoscape.min.js"></script>
    <script src="/vendor/layout-base.js"></script>
    <script src="/vendor/cose-base.js"></script>
    <script src="/vendor/cytoscape-fcose.js"></script>
    <script src="/js/chat.js"></script>
    <script defer src="/js/map.js"></script>
    <script>
        // Initialize with system prompt from server
        document.addEventListener('DOMContentLoaded', () => {
            window.systemPrompt = {{ systemPrompt | dump | safe }};
            new AIRPGChat();
            
            // Add save/load functionality
            initSaveLoadButtons();
            
            // Initialize tabs
            initTabs();

            // Initialize location display
            initLocationDisplay();

            if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                window.loadRegionMap?.();
            }
        });

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.classList.contains('active')) {
                        return;
                    }

                    tabButtons.forEach(btn => {
                        const isActive = btn === button;
                        btn.classList.toggle('active', isActive);
                        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                    });

                    tabPanels.forEach(panel => {
                        const isActive = panel.id === `tab-${button.dataset.tab}`;
                        panel.toggleAttribute('hidden', !isActive);
                        panel.classList.toggle('active', isActive);
                    });
                });
            });
        }

        function initLocationDisplay() {
            // Function to update location display
            const locationCache = {};
            const pendingImagePolls = new Map();
            const locationOverlay = document.getElementById('locationOverlay');
            const locationOverlayText = document.getElementById('locationOverlayText');
            const locationNPCs = document.getElementById('locationNPCs');

            function showLocationOverlay(message = 'Loading location...') {
                if (locationOverlay) {
                    locationOverlay.classList.add('show');
                    locationOverlay.setAttribute('aria-busy', 'true');
                    if (locationOverlayText && message) {
                        locationOverlayText.textContent = message;
                    }
                }
            }

            function hideLocationOverlay() {
                if (locationOverlay) {
                    locationOverlay.classList.remove('show');
                    locationOverlay.setAttribute('aria-busy', 'false');
                }
            }

            window.updateLocationDisplay = function(location) {
                const locationName = document.getElementById('locationName');
            const locationTooltip = document.getElementById('locationTooltip');
            const locationHint = document.getElementById('locationHint');
                const locationLevel = document.getElementById('locationLevel');
                const locationImage = document.getElementById('locationImage');
            const locationExits = document.getElementById('locationExits');
                
                if (location) {
                    locationName.textContent = location.name || 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = location.description || 'No description available.';
                    }
                    if (locationHint) {
                        if (location.pendingImageJobId) {
                            locationHint.textContent = 'Generating location image...';
                        } else {
                            locationHint.textContent = location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.';
                        }
                    }
                    locationLevel.textContent = `Level: ${location.baseLevel || '?'}`;
                locationCache[location.id] = location.name || location.description || location.id;
                    
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        if (location.imageId && !location.pendingImageJobId) {
                            locationImage.innerHTML = `<img src="/generated-images/${location.imageId}.png" alt="${location.name}" onerror="this.parentElement.innerHTML='<div class=\\'location-placeholder\\'>üèûÔ∏è<p>Image not found</p></div>'">`;
                        } else {
                            locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                        }
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                    }

                    if (locationExits) {
                        const exitEntries = Object.entries(location.exits || {});
                        if (exitEntries.length === 0) {
                            locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                        } else {
                            locationExits.innerHTML = '';
                            exitEntries.forEach(([key, exit]) => {
                                if (!exit || !exit.destination) {
                                    return;
                                }
                                const button = document.createElement('button');
                                button.className = 'exit-button';
                                const targetName = exit.destinationName || locationCache[exit.destination] || exit.description || exit.destination;
                                button.textContent = targetName;
                                button.dataset.destinationId = exit.destination;
                                button.addEventListener('click', () => moveToLocation(exit.destination));
                                locationExits.appendChild(button);
                            });
                        }
                    }

                    if (locationNPCs) {
                        const npcs = Array.isArray(location.npcs) ? location.npcs : [];
                        if (npcs.length === 0) {
                            locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                        } else {
                            locationNPCs.innerHTML = '';
                            npcs.forEach(npc => {
                                const card = document.createElement('div');
                                card.className = 'npc-card';

                                const portrait = document.createElement('div');
                                portrait.className = 'npc-portrait';
                                if (npc.description) {
                                    portrait.title = npc.description;
                                }

                                if (npc.imageId) {
                                    portrait.innerHTML = `<img src="/generated-images/${npc.imageId}.png" alt="${npc.name}" onerror="this.parentElement.innerHTML='<div class=\\'npc-portrait-placeholder\\'>üé≠</div>'">`;
                                } else {
                                    portrait.innerHTML = '<div class="npc-portrait-placeholder">üé≠</div>';
                                }

                                const nameEl = document.createElement('div');
                                nameEl.className = 'npc-name';
                                nameEl.textContent = npc.name || 'Unknown NPC';

                                card.appendChild(portrait);
                                card.appendChild(nameEl);
                                locationNPCs.appendChild(card);
                            });
                        }
                    }

                    if (location.pendingImageJobId) {
                        startImagePolling(location.id, location.pendingImageJobId);
                    } else {
                        stopImagePolling(location.id);
                    }
                hideLocationOverlay();
                } else {
                    locationName.textContent = 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = 'Your current location will appear here when you start exploring.';
                    }
                    if (locationHint) {
                        locationHint.textContent = 'Hover over the location image for a description.';
                    }
                    locationLevel.textContent = 'Level: ?';
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                    }
                    if (locationNPCs) {
                        locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                    }
                    if (locationExits) {
                        locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                    }
                stopImagePolling();
                hideLocationOverlay();
                }
            };

            async function moveToLocation(destinationId) {
                if (!destinationId) return;
                try {
                    showLocationOverlay('Exploring new location...');
                    const response = await fetch('/api/player/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destinationId })
                    });

                    const result = await response.json();
                    if (result.success && result.location) {
                        if (result.location.name) {
                            locationCache[result.location.id] = result.location.name;
                        }
                        if (Array.isArray(result.location.exits)) {
                            result.location.exits.forEach(exit => {
                                if (exit.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        } else if (result.location.exits) {
                            Object.values(result.location.exits).forEach(exit => {
                                if (exit?.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        }
                        window.updateLocationDisplay(result.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    } else if (result.error) {
                        hideLocationOverlay();
                        alert(`Move failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Move failed:', error);
                    hideLocationOverlay();
                    alert(`Move failed: ${error.message}`);
                }
            }

            function startImagePolling(locationId, jobId) {
                if (!locationId || !jobId) return;
                const existing = pendingImagePolls.get(locationId);
                if (existing) {
                    if (existing.jobId === jobId) {
                        return;
                    }
                    clearInterval(existing.interval);
                }

                const interval = setInterval(async () => {
                    try {
                        const jobResponse = await fetch(`/api/jobs/${jobId}`);
                        if (!jobResponse.ok) {
                            throw new Error(`Job status ${jobResponse.status}`);
                        }
                        const jobData = await jobResponse.json();
                        if (!jobData.success) {
                            throw new Error(jobData.error || 'Job status error');
                        }

                        const status = jobData.job?.status;
                        if (status === 'completed') {
                            stopImagePolling(locationId);
                            const locResponse = await fetch(`/api/locations/${locationId}`);
                            const locData = await locResponse.json();
                            if (locData.success && locData.location) {
                                window.updateLocationDisplay(locData.location);
                            }
                        } else if (status === 'failed' || status === 'timeout') {
                            stopImagePolling(locationId);
                            const locationHint = document.getElementById('locationHint');
                            if (locationHint) {
                                locationHint.textContent = `Image generation ${status}.`;
                            }
                        }
                    } catch (error) {
                        console.warn('Image polling error:', error.message);
                    }
                }, 4000);

                pendingImagePolls.set(locationId, { interval, jobId });
            }

            function stopImagePolling(locationId = null) {
                if (locationId) {
                    const entry = pendingImagePolls.get(locationId);
                    if (entry) {
                        clearInterval(entry.interval);
                        pendingImagePolls.delete(locationId);
                    }
                } else {
                    for (const entry of pendingImagePolls.values()) {
                        clearInterval(entry.interval);
                    }
                    pendingImagePolls.clear();
                }
            }

            // Load current player location on page load
            showLocationOverlay('Loading current location...');
            loadCurrentLocation().finally(() => hideLocationOverlay());
        }

        async function loadCurrentLocation() {
            try {
                const response = await fetch('/api/player');
                const result = await response.json();
                
                if (result.success && result.player && result.player.currentLocation) {
                    // Fetch location details
                    const locationResponse = await fetch(`/api/locations/${result.player.currentLocation}`);
                    const locationResult = await locationResponse.json();
                    
                    if (locationResult.success && locationResult.location) {
                        window.updateLocationDisplay(locationResult.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load current location:', error);
                hideLocationOverlay();
            }
        }

        function initSaveLoadButtons() {
            const saveGameBtn = document.getElementById('saveGameBtn');
            const loadGameBtn = document.getElementById('loadGameBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            
            saveGameBtn.addEventListener('click', async function() {
                try {
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Saving...';
                    
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> Saved!';
                        alert(`Game saved successfully!\n\nSave: ${result.saveName}`);
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Save Failed';
                        alert(`Save failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Save Failed';
                    alert(`Save failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üíæ</span> Save Game';
                    }, 2000);
                }
            });

            loadGameBtn.addEventListener('click', async function() {
                try {
                    const response = await fetch('/api/saves');
                    const result = await response.json();
                    
                    if (!result.success || result.saves.length === 0) {
                        alert('No saves found!');
                        return;
                    }
                    
                    // Create a selection dialog
                    let saveOptions = 'Select a save to load:\n\n';
                    result.saves.forEach((save, index) => {
                        const timestamp = new Date(save.timestamp).toLocaleString();
                        saveOptions += `${index + 1}. ${save.playerName} (Level ${save.playerLevel}) - ${timestamp}\n`;
                    });
                    
                    const selection = prompt(saveOptions + '\nEnter the number of the save to load (or 0 to cancel):');
                    const saveIndex = parseInt(selection) - 1;
                    
                    if (saveIndex >= 0 && saveIndex < result.saves.length) {
                        const selectedSave = result.saves[saveIndex];
                        
                        if (confirm(`Load save: ${selectedSave.playerName} (${new Date(selectedSave.timestamp).toLocaleString()})?`)) {
                            this.disabled = true;
                            this.innerHTML = '<span>‚è≥</span> Loading...';
                            
                            const loadResponse = await fetch('/api/load', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ saveName: selectedSave.saveName })
                            });
                            
                            const loadResult = await loadResponse.json();
                            
                            if (loadResult.success) {
                                alert(`Game loaded successfully!\n\n${loadResult.message}`);
                                window.location.reload();
                            } else {
                                alert(`Load failed: ${loadResult.error}`);
                            }
                        }
                    }
                } catch (error) {
                    alert(`Load failed: ${error.message}`);
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<span>üìÇ</span> Load Game';
                }
            });

            if (newGameBtn) {
            newGameBtn.addEventListener('click', async function() {
                try {
                    const confirmation = confirm('Start a new game? This will clear your current progress.\n\nYou can optionally enter a custom player name and description.');
                    if (!confirmation) return;
                    
                    // Get optional player details
                    const playerName = prompt('Enter your character name (or leave blank for "Adventurer"):') || 'Adventurer';
                    const playerDescription = prompt('Enter your character description (optional):') || 'A brave soul embarking on a new adventure.';
                    
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Creating...';
                    
                    const response = await fetch('/api/new-game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playerName: playerName,
                            playerDescription: playerDescription
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> New Game Started!';
                        alert(`New game created successfully!\n\nPlayer: ${result.player.name}\nStarting Location: ${result.startingLocation.name}\n\nYour adventure begins now!`);
                        window.location.reload();
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Failed';
                        alert(`New game creation failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Failed';
                    alert(`New game creation failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üÜï</span> New Game';
                    }, 2000);
                }
            });
            }
        }
    </script>
</body>
</html>
