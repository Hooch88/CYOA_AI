<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("AI RPG Chat") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/map.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI RPG Chat Interface ü§ñ</h1>
            {% include "_navigation.njk" %}
        </div>
        
        <div class="main-content">
            <div class="tab-bar" role="tablist">
                <button class="tab-button active" id="tab-adventure-tab" data-tab="adventure" role="tab" aria-selected="true" aria-controls="tab-adventure">Adventure</button>
                <button class="tab-button" id="tab-map-tab" data-tab="map" role="tab" aria-selected="false" aria-controls="tab-map">Map</button>
                <button class="tab-button" id="tab-character-tab" data-tab="character" role="tab" aria-selected="false" aria-controls="tab-character">Character</button>
                <button class="tab-button" id="tab-party-tab" data-tab="party" role="tab" aria-selected="false" aria-controls="tab-party">Party</button>
                <button class="tab-button" id="tab-inventory-tab" data-tab="inventory" role="tab" aria-selected="false" aria-controls="tab-inventory">Inventory</button>
            </div>

            <div class="tab-panels">
                <section class="tab-panel active" id="tab-adventure" role="tabpanel" aria-labelledby="tab-adventure-tab">
                    <div class="adventure-content">
                        <div class="location-block">
                            <div class="container">
                                <div class="location-header">
                                    <h4>üìç <span class="location-name" id="locationName">Unknown Location</span></h4>
                                </div>
                                <div class="location-content" id="locationContent">
                                    <div class="location-image" id="locationImage">
                                        <div class="location-placeholder">
                                            <!-- Nothing in here on initial load -->
                                        </div>
                                        <div class="location-tooltip" id="locationTooltip">Your current location will appear here when you start exploring.</div>
                                    </div>
                                    <div class="location-info" id="locationInfo">
                                        <div class="location-details" id="locationDetails">
                                            <span class="location-level" id="locationLevel">Level: ?</span>
                                        </div>
                                        <div class="location-hint" id="locationHint">Hover over the location image for a description.</div>
                                        <details class="location-section location-exits" open>
                                            <summary>Exits</summary>
                                            <div class="location-exits-content" id="locationExits">
                                                <div class="no-exits">No exits discovered yet.</div>
                                            </div>
                                        </details>
                                        <details class="location-section location-npcs" open>
                                            <summary>NPCs</summary>
                                            <div class="location-entity-grid" id="locationNPCs">
                                                <div class="location-npc-empty">No notable NPCs present.</div>
                                            </div>
                                        </details>
                                        <details class="location-section location-things" open>
                                            <summary>Items &amp; Scenery</summary>
                                            <div class="location-entity-grid" id="locationThings">
                                                <div class="location-thing-empty">No notable items or scenery present.</div>
                                            </div>
                                        </details>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="chat-wrapper">
                            <div class="chat-container">
                                <div class="chat-log" id="chatLog">
                                    {% if chatHistory and chatHistory.length > 0 %}
                                        {% for message in chatHistory %}
                                            <div class="message {{ 'user-message' if message.role == 'user' else 'ai-message' }}">
                                                <div class="message-sender">
                                                    {% if message.role == 'user' %}
                                                        üë§ You
                                                    {% else %}
                                                        ü§ñ AI Game Master
                                                    {% endif %}
                                                </div>
                                                <div>{{ message.content }}</div>
                                                <div class="message-timestamp">{{ message.timestamp | replace('T', ' ') | replace('Z', '') }}</div>
                                            </div>
                                        {% endfor %}
                                    {% else %}
                                        <div class="message ai-message">
                                            <div class="message-sender">ü§ñ AI Game Master</div>
                                            <div>Welcome to the AI RPG! I'm your Game Master. Configure your AI settings above and then describe what kind of adventure you'd like to embark on.</div>
                                        </div>
                                    {% endif %}
                                </div>

                                <div class="input-area">
                                    <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
                                    <button class="send-button" id="sendButton">Send</button>
                                </div>
                            </div>

                            <aside class="chat-sidebar" aria-label="Player and party overview">
                                <section class="chat-player-section">
                                    <h3 class="chat-sidebar-heading">Player</h3>
                                    <div class="chat-player-card" id="chatPlayerCard">
                                        <div class="chat-player-portrait" id="chatPlayerPortrait">
                                            <div class="chat-player-placeholder" aria-hidden="true">üßô</div>
                                        </div>
                                        <div class="chat-player-details">
                                            <div class="chat-player-name" id="chatPlayerName">Unnamed Adventurer</div>
                                            <div class="chat-player-meta">
                                                <span class="chat-player-level" id="chatPlayerLevel">Level ?</span>
                                                <span class="chat-player-archetype" id="chatPlayerArchetype">Class ¬∑ Race</span>
                                            </div>
                                            <div class="chat-player-health" id="chatPlayerHealth">HP: ? / ?</div>
                                            <p class="chat-player-description" id="chatPlayerDescription">No description available.</p>
                                        </div>
                                    </div>
                                </section>

                                <section class="chat-party-section">
                                    <div class="chat-party-header">
                                        <h3 class="chat-sidebar-heading">Party</h3>
                                        <span class="chat-party-count" id="chatPartyCount">0</span>
                                    </div>
                                    <div class="chat-party-empty" id="chatPartyEmpty">No companions are currently travelling with you.</div>
                                    <div class="location-entity-grid chat-party-grid" id="chatPartyMembers"></div>
                                </section>
                            </aside>
                        </div>
                    </div>
                </section>

                <section class="tab-panel" id="tab-map" role="tabpanel" aria-labelledby="tab-map-tab" hidden>
                    <div class="map-panel">
                        <div class="map-header">
                            <h2 id="mapTitle" class="map-title">Region Map</h2>
                        </div>
                        <div id="mapContainer" class="map-placeholder" aria-live="polite"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-character" role="tabpanel" aria-labelledby="tab-character-tab" hidden>
                    <div class="config-content character-panel">
                        <div class="config-section">
                            <h2>Basic Information</h2>
                            <form id="player-stats-form" class="player-stats-form">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label for="player-name">Character Name</label>
                                        <input type="text"
                                               id="player-name"
                                               name="name"
                                               value="{{ player.name if player else '' }}"
                                               placeholder="Enter character name"
                                               required>
                                        <span class="help-text">Your character's name as it appears in the game</span>
                                    </div>

                                    <div class="form-group">
                                        <label for="player-level">Level</label>
                                        <input type="number"
                                               id="player-level"
                                               name="level"
                                               value="{{ player.level if player else 1 }}"
                                               min="1"
                                               max="20"
                                               required>
                                        <span class="help-text">Character level (1-20)</span>
                                    </div>

                                    <div class="form-group full-width">
                                        <label for="player-description">Description</label>
                                        <textarea id="player-description"
                                                  name="description"
                                                  rows="3"
                                                  placeholder="Describe your character's appearance, personality, and background">{{ player.description if player else '' }}</textarea>
                                        <span class="help-text">A detailed description of your character</span>
                                    </div>
                                </div>
                            </form>
                        </div>

                        <div class="config-section">
                            <h2>Health &amp; Vitality</h2>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="player-health">Current Health</label>
                                    <input type="number"
                                           id="player-health"
                                           name="health"
                                           value="{{ player.health if player else 25 }}"
                                           min="0"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Current hit points</span>
                                </div>

                                <div class="form-group">
                                    <label for="player-max-health">Maximum Health</label>
                                    <input type="number"
                                           id="player-max-health"
                                           name="maxHealth"
                                           value="{{ player.maxHealth if player else 25 }}"
                                           min="1"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Maximum hit points</span>
                                </div>
                            </div>
                        </div>

                        <div class="config-section">
                            <h2>Primary Attributes</h2>
                            <div class="attributes-grid">
                                {% set attributes = player.attributeInfo if player else {} %}
                                {% set defaultAttributes = [
                                    { key: 'strength', label: 'Strength', abbr: 'STR', description: 'Physical power and muscle' },
                                    { key: 'dexterity', label: 'Dexterity', abbr: 'DEX', description: 'Agility and reflexes' },
                                    { key: 'constitution', label: 'Constitution', abbr: 'CON', description: 'Health and stamina' },
                                    { key: 'intelligence', label: 'Intelligence', abbr: 'INT', description: 'Mental acuity and reasoning' },
                                    { key: 'wisdom', label: 'Wisdom', abbr: 'WIS', description: 'Insight and perception' },
                                    { key: 'charisma', label: 'Charisma', abbr: 'CHA', description: 'Charm and influence' }
                                ] %}

                                {% for attr in defaultAttributes %}
                                <div class="attribute-group">
                                    <div class="attribute-header">
                                        <label for="attr-{{ attr.key }}">{{ attr.label }}</label>
                                        <span class="attribute-abbr">{{ attr.abbr }}</span>
                                    </div>
                                    <div class="attribute-input-group">
                                        <input type="number"
                                               id="attr-{{ attr.key }}"
                                               name="attributes.{{ attr.key }}"
                                               value="{{ attributes[attr.key].value if attributes[attr.key] else 10 }}"
                                               min="3"
                                               max="18"
                                               form="player-stats-form"
                                               class="attribute-input">
                                        <span class="attribute-modifier" data-attr="{{ attr.key }}">
                                            +{{ ((attributes[attr.key].value if attributes[attr.key] else 10) - 10) // 2 }}
                                        </span>
                                    </div>
                                    <span class="help-text">{{ attr.description }}</span>
                                </div>
                                {% endfor %}
                        </div>
                    </div>

                        {% if availableSkills and availableSkills|length %}
                        <div class="config-section">
                            <h2>Skills</h2>
                            <div class="skill-pool-display">
                                <span class="status-label">Unspent Skill Points:</span>
                                <span class="status-value" id="unspentSkillPointsDisplay">{{ player.unspentSkillPoints if player else 0 }}</span>
                            </div>
                            <div class="skills-grid readonly">
                                {% for skill in availableSkills %}
                                {% set skillValue = player.skills[skill.name] if player and player.skills and skill.name in player.skills else 1 %}
                                <div class="skill-card readonly">
                                    <div class="skill-header">
                                        <span class="skill-name">{{ skill.name }}</span>
                                        {% if skill.attribute %}<span class="skill-attribute">{{ skill.attribute }}</span>{% endif %}
                                    </div>
                                    <div class="skill-value">
                                        Rank: <span class="skill-rank" data-skill-name="{{ skill.name }}">{{ skillValue }}</span>
                                        {% if player %}
                                        <button type="button"
                                                class="btn btn-secondary small skill-increase-btn"
                                                data-skill-name="{{ skill.name }}"
                                                aria-label="Increase {{ skill.name }}">
                                            ‚ûï
                                        </button>
                                        {% endif %}
                                    </div>
                                    {% if skill.description %}
                                    <div class="skill-description">{{ skill.description }}</div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="config-section" id="abilitiesSection">
                            <h2>Abilities</h2>
                            <div class="abilities-grid" id="abilitiesList">
                                {% if player and player.abilities %}
                                    {% for ability in player.abilities %}
                                        <div class="ability-card ability-type-{{ ability.type | default('Passive') | lower }}">
                                            <div class="ability-header">
                                                <span class="ability-name">{{ ability.name }}</span>
                                                <span class="ability-meta">{{ ability.type | default('Passive') }}{% if ability.level %} ‚Ä¢ Level {{ ability.level }}{% endif %}</span>
                                            </div>
                                            {% if ability.description %}
                                            <div class="ability-description">{{ ability.description }}</div>
                                            {% endif %}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                            <div class="abilities-empty" id="abilitiesEmpty" {% if player and player.abilities and player.abilities|length %}hidden{% endif %}>
                                No special abilities unlocked yet.
                            </div>
                        </div>

                        {% if player %}
                        <div class="config-section">
                            <h2>Current Status</h2>
                            <div class="status-display">
                                <div class="status-item">
                                    <span class="status-label">Alive:</span>
                                    <span class="status-value {{ 'alive' if player.alive else 'dead' }}">
                                        {{ 'Yes' if player.alive else 'No' }}
                                    </span>
                                </div>
                                {% if player.currentLocation %}
                                <div class="status-item">
                                    <span class="status-label">Location:</span>
                                    <span class="status-value">{{ player.currentLocation }}</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="form-actions">
                            <button type="submit" form="player-stats-form" class="btn btn-primary">
                                <span>üíæ</span> Save Character
                            </button>
                            {% if player %}
                            <button type="button" id="reset-stats" class="btn btn-secondary">
                                <span>üîÑ</span> Reset to Defaults
                            </button>
                            {% endif %}
                        </div>

                        <div id="status-message" class="status-message" style="display: none;"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-party" role="tabpanel" aria-labelledby="tab-party-tab" hidden>
                    <div class="party-panel">
                        <div class="party-header">
                            <h2>Party Members</h2>
                            <span class="party-count" id="partyCount">0 members</span>
                        </div>
                        <div class="party-grid" id="partyMembers"></div>
                        <div class="party-empty" id="partyEmpty">No companions are currently travelling with you.</div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-inventory" role="tabpanel" aria-labelledby="tab-inventory-tab" hidden>
                    <div class="inventory-layout">
                        <div class="equipment-panel">
                            <div class="equipment-header">
                                <h2>Equipment</h2>
                            </div>
                            <div class="equipment-slots" id="equipmentSlots"></div>
                            <div class="equipment-empty" id="equipmentEmpty">No equipment slots available.</div>
                        </div>
                        <div class="inventory-panel">
                            <div class="inventory-header">
                                <h2>Inventory</h2>
                                <span class="inventory-count" id="inventoryCount">0 items</span>
                            </div>
                            <div class="inventory-scroll">
                                <div class="inventory-grid" id="inventoryItems"></div>
                            </div>
                            <div class="inventory-empty" id="inventoryEmpty">Inventory is empty.</div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <div id="locationOverlay" class="overlay-backdrop" aria-live="polite" aria-busy="false" aria-label="Loading location">
        <div class="overlay-content">
            <div class="spinner" role="status" aria-hidden="true"></div>
            <div class="overlay-text" id="locationOverlayText">Exploring...</div>
        </div>
    </div>

    <div id="npcModalBackdrop" class="modal-backdrop" hidden></div>
    <div id="npcInventoryModal" class="modal npc-inventory-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcInventoryModalTitle">NPC Inventory</h2>
                <button type="button" class="modal__close" id="npcInventoryCloseBtn" aria-label="Close NPC inventory">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-inventory-body">
                <div class="npc-inventory-header">
                    <h3 id="npcInventoryName">Character</h3>
                    <span class="inventory-count" id="npcInventoryCount">0 items</span>
                </div>
                <div class="npc-inventory-scroll">
                    <div class="inventory-grid" id="npcInventoryGrid"></div>
                </div>
                <div class="inventory-empty" id="npcInventoryEmpty">Inventory is empty.</div>
            </div>
        </div>
    </div>
    <div id="npcViewModal" class="modal npc-view-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcViewModalTitle">Character Overview</h2>
                <button type="button" class="modal__close" id="npcViewCloseBtn" aria-label="Close character overview">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <div class="modal__body npc-view-body">
                <div class="npc-view-summary">
                    <div class="npc-view-image" id="npcViewImage"></div>
                    <div class="npc-view-summary-text">
                        <h3 id="npcViewName">Unknown Character</h3>
                        <p id="npcViewDescription" class="npc-view-description">No description available.</p>
                        <div class="npc-view-tags" id="npcViewTags">
                            <span class="npc-view-tag" id="npcViewClass"></span>
                            <span class="npc-view-tag" id="npcViewRace"></span>
                            <span class="npc-view-tag" id="npcViewLevel"></span>
                        </div>
                        <div class="npc-view-health" id="npcViewHealth"></div>
                        <div class="npc-view-meta" id="npcViewCurrency" hidden></div>
                        <div class="npc-view-meta" id="npcViewExperience" hidden></div>
                    </div>
                </div>
                <div class="npc-view-sections">
                    <section class="npc-view-section" id="npcViewAttributesSection">
                        <h4>Attributes</h4>
                        <dl class="npc-view-attributes" id="npcViewAttributes"></dl>
                        <div class="npc-view-empty" id="npcViewAttributesEmpty">No attribute data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewEquipmentSection">
                        <h4>Equipment</h4>
                        <dl class="npc-view-equipment" id="npcViewEquipment"></dl>
                        <div class="npc-view-empty" id="npcViewEquipmentEmpty">No equipment equipped.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewSkillsSection">
                        <h4>Skills</h4>
                        <div class="npc-view-skills" id="npcViewSkills"></div>
                        <div class="npc-view-empty" id="npcViewSkillsEmpty">No skill data available.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewAbilitiesSection">
                        <h4>Abilities</h4>
                        <ul class="npc-view-list" id="npcViewAbilities"></ul>
                        <div class="npc-view-empty" id="npcViewAbilitiesEmpty">No abilities listed.</div>
                    </section>
                    <section class="npc-view-section" id="npcViewStatusSection">
                        <h4>Status Effects</h4>
                        <ul class="npc-view-list" id="npcViewStatuses"></ul>
                        <div class="npc-view-empty" id="npcViewStatusesEmpty">No active status effects.</div>
                    </section>
                </div>
                <details class="npc-view-dispositions" id="npcViewDispositions" hidden>
                    <summary>Dispositions</summary>
                    <div class="npc-view-disposition-list" id="npcViewDispositionsList"></div>
                </details>
            </div>
        </div>
    </div>
    <div id="npcEditModal" class="modal npc-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="npcEditModalTitle">Edit NPC</h2>
                <button type="button" class="modal__close" id="npcEditCloseBtn" aria-label="Close NPC editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="npcEditForm" class="modal__body" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="npcEditId">Character ID</label>
                        <input id="npcEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditName">Name</label>
                        <input id="npcEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field npc-edit-field--wide">
                        <label for="npcEditShortDescription">Short Description</label>
                        <input id="npcEditShortDescription" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditRace">Race</label>
                        <input id="npcEditRace" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditClass">Class</label>
                        <input id="npcEditClass" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditLevel">Level</label>
                        <input id="npcEditLevel" type="number" min="1" max="20" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealth">Health</label>
                        <input id="npcEditHealth" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditHealthAttribute">Health Bonus Attribute</label>
                        <select id="npcEditHealthAttribute"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditMaxHealth">Max Health</label>
                        <input id="npcEditMaxHealth" type="number" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditUnspent">Unspent Skill Points</label>
                        <input id="npcEditUnspent" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditCurrency">Currency</label>
                        <input id="npcEditCurrency" type="number" min="0" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="npcEditExperience">Experience</label>
                        <input id="npcEditExperience" type="number" min="0" step="1">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="npcEditDescription">Description</label>
                    <textarea id="npcEditDescription" rows="4"></textarea>
                </div>

                <div class="npc-edit-section">
                    <h3>Attributes</h3>
                    <div id="npcEditAttributes" class="npc-attribute-grid"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Skills</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddSkillBtn">Add Skill</button>
                    </div>
                    <div id="npcEditSkills" class="npc-skill-list"></div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Abilities</h3>
                        <button type="button" class="npc-edit-add-btn" id="npcAddAbilityBtn">Add Ability</button>
                    </div>
                    <div id="npcEditAbilities" class="npc-ability-list"></div>
                </div>

                <div class="npc-edit-footer">
                    <div id="npcEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="npcEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="npcEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="thingEditModal" class="modal thing-edit-modal" role="dialog" aria-modal="true" aria-hidden="true" hidden>
        <div class="modal__dialog">
            <header class="modal__header">
                <h2 id="thingEditModalTitle">Edit Item</h2>
                <button type="button" class="modal__close" id="thingEditCloseBtn" aria-label="Close item editor">
                    <span aria-hidden="true">X</span>
                </button>
            </header>
            <form id="thingEditForm" class="modal__body npc-edit-form" novalidate>
                <div class="npc-edit-grid">
                    <div class="npc-edit-field">
                        <label for="thingEditId">Item ID</label>
                        <input id="thingEditId" type="text" readonly>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditName">Name</label>
                        <input id="thingEditName" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditType">Type</label>
                        <select id="thingEditType">
                            <option value="item">Item</option>
                            <option value="scenery">Scenery</option>
                        </select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditRarity">Rarity</label>
                        <select id="thingEditRarity"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditItemDetail">Item Detail</label>
                        <input id="thingEditItemDetail" type="text" autocomplete="off">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditSlot">Slot</label>
                        <select id="thingEditSlot"></select>
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditLevel">Level</label>
                        <input id="thingEditLevel" type="number" min="1" max="20" step="1">
                    </div>
                    <div class="npc-edit-field">
                        <label for="thingEditImageId">Image ID</label>
                        <input id="thingEditImageId" type="text" autocomplete="off">
                    </div>
                </div>

                <div class="npc-edit-section">
                    <label for="thingEditDescription">Description</label>
                    <textarea id="thingEditDescription" rows="4"></textarea>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Metadata</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingMetadataAddBtn">Add Entry</button>
                    </div>
                    <div id="thingEditMetadataList" class="thing-edit-metadata-list"></div>
                    <p class="npc-edit-hint">Use metadata for additional properties like value, weight, or lore tags.</p>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Attribute Bonuses</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingAttributeBonusAddBtn">Add Bonus</button>
                    </div>
                    <div id="thingEditAttributeBonusesList" class="thing-edit-bonus-list"></div>
                </div>

                <div class="npc-edit-section">
                    <h3>On-Hit Status Effect</h3>
                    <div class="thing-edit-cause-effect">
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectName">Name</label>
                            <input id="thingEditCauseStatusEffectName" type="text" autocomplete="off">
                        </div>
                        <div class="npc-edit-field npc-edit-field--wide">
                            <label for="thingEditCauseStatusEffectDescription">Description</label>
                            <textarea id="thingEditCauseStatusEffectDescription" rows="2"></textarea>
                        </div>
                        <div class="npc-edit-field">
                            <label for="thingEditCauseStatusEffectDuration">Duration</label>
                            <input id="thingEditCauseStatusEffectDuration" type="text" autocomplete="off" placeholder="e.g. 3 or permanent">
                        </div>
                    </div>
                </div>

                <div class="npc-edit-section">
                    <div class="npc-edit-section-header">
                        <h3>Status Effects</h3>
                        <button type="button" class="npc-edit-add-btn" id="thingStatusEffectAddBtn">Add Effect</button>
                    </div>
                    <div id="thingEditStatusEffectsList" class="thing-edit-status-effects"></div>
                </div>

                <div class="npc-edit-footer">
                    <div id="thingEditStatus" class="npc-edit-status" role="status" aria-live="polite"></div>
                    <div class="npc-edit-actions">
                        <button type="button" class="npc-edit-cancel" id="thingEditCancelBtn">Cancel</button>
                        <button type="submit" class="npc-edit-save-btn" id="thingEditSaveBtn">Save Changes</button>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <div id="inventoryTooltip" class="inventory-floating-tooltip" hidden></div>
    <div id="partyTooltip" class="inventory-floating-tooltip party-floating-tooltip" hidden></div>

    <div id="imageLightbox" class="image-lightbox" hidden aria-hidden="true" tabindex="-1">
        <div class="image-lightbox__inner" role="dialog" aria-modal="true" aria-labelledby="imageLightboxCaption">
            <img id="imageLightboxImage" class="image-lightbox__image" alt="" src="" loading="lazy">
            <div id="imageLightboxCaption" class="image-lightbox__caption" hidden></div>
        </div>
    </div>

    <script src="/vendor/fitty.min.js"></script>
    <script src="/js/fitty-init.js"></script>
    <script src="/vendor/cytoscape.min.js"></script>
    <script src="/vendor/layout-base.js"></script>
    <script src="/vendor/cose-base.js"></script>
    <script src="/vendor/cytoscape-fcose.js"></script>
    <script src="/js/lightbox.js"></script>
    <script src="/js/image-manager.js"></script>
    <script src="/js/chat.js"></script>
    <script defer src="/js/map.js"></script>
    <script defer src="/js/player-stats.js"></script>
    <script>
        window.currentSetting = {{ (currentSetting or {}) | dump | safe }};
        // Initialize with system prompt from server
        document.addEventListener('DOMContentLoaded', () => {
            window.systemPrompt = {{ systemPrompt | dump | safe }};
            new AIRPGChat();
            
            // Add save/load functionality
            initSaveLoadButtons();
            
            // Initialize tabs
            initTabs();

            // Initialize location display
            initLocationDisplay();
            initInventoryDisplay();
            initPartyDisplay();
        });

        function bindLightboxElement(element, dataProvider) {
            if (!element || !window.lightboxController) {
                return;
            }

            try {
                window.lightboxController.bind(element, dataProvider);
            } catch (error) {
                console.warn('Failed to bind lightbox:', error);
            }
        }

        const escapeHtml = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };

        function renderEntityImage({
            element,
            entityType,
            entityId,
            imageId,
            altText,
            placeholderIcon = 'üñºÔ∏è',
            placeholderClass = 'image-placeholder',
            placeholderMarkup = null,
            enableLightbox = true,
            force = false
        }) {
            if (!element) {
                return Promise.resolve(null);
            }

            const safeAltText = escapeHtml(altText || '');
            const computedPlaceholderMarkup = placeholderMarkup !== null
                ? placeholderMarkup
                : `<div class="${placeholderClass}">${placeholderIcon}</div>`;

            const applyImageMarkup = (url) => {
                if (!url) {
                    element.innerHTML = computedPlaceholderMarkup;
                    return;
                }

                element.innerHTML = `<img src="${url}" alt="${safeAltText}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'${placeholderClass}\\' role=\\'img\\'>${placeholderIcon}</div>'">`;
                const img = element.querySelector('img');
                if (img && enableLightbox) {
                    img.dataset.lightboxImage = img.src;
                    img.dataset.lightboxAlt = altText || safeAltText || 'Image';
                    img.dataset.lightboxCaption = altText || '';
                    bindLightboxElement(img);
                }
            };

            const setPlaceholder = () => {
                element.innerHTML = computedPlaceholderMarkup;
            };

            element.dataset.imageEntityType = entityType || '';
            element.dataset.imageEntityId = entityId || '';
            element.dataset.imagePlaceholder = placeholderIcon || 'üñºÔ∏è';
            element.dataset.imagePlaceholderClass = placeholderClass || 'image-placeholder';
            if (placeholderMarkup !== null && placeholderMarkup !== undefined) {
                element.dataset.imagePlaceholderMarkup = placeholderMarkup;
            } else {
                delete element.dataset.imagePlaceholderMarkup;
            }
            element.dataset.imageAlt = altText || '';
            element.dataset.imageLightbox = enableLightbox ? 'true' : 'false';
            element.dataset.imageAuto = 'true';
            if (force) {
                element.dataset.imageForce = 'true';
            } else {
                delete element.dataset.imageForce;
            }

            element.dataset.imageProcessing = 'true';

            if (imageId) {
                element.dataset.imageId = imageId;
                applyImageMarkup(`/generated-images/${imageId}.png`);
            } else {
                delete element.dataset.imageId;
                setPlaceholder();
            }

            const finalize = (result) => {
                delete element.dataset.imageProcessing;
                element.dataset.imageInitialized = 'true';
                return result;
            };

            const manager = window.AIRPG?.imageManager;
            if (!manager || !entityType || !entityId) {
                return Promise.resolve(finalize(null));
            }

            return manager.ensureImage({
                entityType,
                entityId,
                existingImageId: imageId || null,
                force: Boolean(force)
            }).then(result => {
                if (result?.imageId) {
                    element.dataset.imageId = result.imageId;
                }

                const imageUrl = result?.imageUrl || (result?.imageId ? `/generated-images/${result.imageId}.png` : null);
                if (imageUrl) {
                    applyImageMarkup(imageUrl);
                } else if (!result?.skipped) {
                    setPlaceholder();
                }

                return finalize(result || null);
            }).catch(error => {
                console.warn(`Image generation failed for ${entityType} ${entityId}:`, error?.message || error);
                element.innerHTML = `<div class="${placeholderClass} error">${placeholderIcon}</div>`;
                return finalize(null);
            });
        }

        window.renderEntityImage = renderEntityImage;

        const chatSidebarElements = {
            card: document.getElementById('chatPlayerCard'),
            portrait: document.getElementById('chatPlayerPortrait'),
            name: document.getElementById('chatPlayerName'),
            level: document.getElementById('chatPlayerLevel'),
            archetype: document.getElementById('chatPlayerArchetype'),
            health: document.getElementById('chatPlayerHealth'),
            description: document.getElementById('chatPlayerDescription'),
            partyGrid: document.getElementById('chatPartyMembers'),
            partyEmpty: document.getElementById('chatPartyEmpty'),
            partyCount: document.getElementById('chatPartyCount')
        };

        function updateChatPlayerPanel(player = {}) {
            if (!chatSidebarElements.card) {
                return;
            }

            const name = player?.name || 'Unnamed Adventurer';
            if (chatSidebarElements.name) {
                chatSidebarElements.name.textContent = name;
            }

            const levelLabel = Number.isFinite(player?.level) ? `Level ${player.level}` : 'Level ?';
            if (chatSidebarElements.level) {
                chatSidebarElements.level.textContent = levelLabel;
            }

            const archetypeParts = [];
            if (player?.class) {
                archetypeParts.push(player.class);
            }
            if (player?.race) {
                archetypeParts.push(player.race);
            }
            const archetypeLabel = archetypeParts.length ? archetypeParts.join(' ¬∑ ') : 'Unknown origin';
            if (chatSidebarElements.archetype) {
                chatSidebarElements.archetype.textContent = archetypeLabel;
            }

            const healthCurrent = Number.isFinite(player?.health) ? player.health : '?';
            const healthMaximum = Number.isFinite(player?.maxHealth) ? player.maxHealth : '?';
            if (chatSidebarElements.health) {
                chatSidebarElements.health.textContent = `HP: ${healthCurrent} / ${healthMaximum}`;
            }

            const description = (player?.shortDescription || player?.description || 'No description available.').trim();
            if (chatSidebarElements.description) {
                chatSidebarElements.description.textContent = description;
            }

            if (chatSidebarElements.portrait) {
                renderEntityImage({
                    element: chatSidebarElements.portrait,
                    entityType: 'player',
                    entityId: player?.id || null,
                    imageId: player?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üßô',
                    placeholderClass: 'chat-player-placeholder',
                    enableLightbox: true
                });
            }
        }

        function renderChatPartyPanel(members = []) {
            const container = chatSidebarElements.partyGrid;
            const emptyState = chatSidebarElements.partyEmpty;
            const countLabel = chatSidebarElements.partyCount;
            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            if (!container) {
                if (countLabel) {
                    countLabel.textContent = '0';
                }
                return;
            }

            const safeMembers = Array.isArray(members)
                ? members.filter(member => member && typeof member === 'object')
                : [];
            container.innerHTML = '';

            if (countLabel) {
                countLabel.textContent = String(safeMembers.length);
            }

            if (emptyState) {
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
            }

            container.style.display = safeMembers.length ? 'flex' : 'none';

            const tooltipController = window.floatingTooltipController;

            safeMembers.forEach(member => {
                if (!member) {
                    return;
                }

                const card = document.createElement('div');
                card.className = 'location-entity-card is-npc';

                const portrait = document.createElement('div');
                portrait.className = 'location-entity-icon';

                renderEntityImage({
                    element: portrait,
                    entityType: member.isNPC ? 'npc' : 'player',
                    entityId: member.id || null,
                    imageId: member.imageId || null,
                    altText: member.name || 'Party member portrait',
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'location-entity-placeholder'
                });

                const nameEl = document.createElement('div');
                nameEl.className = 'location-entity-name';
                nameEl.textContent = member.name || 'Unknown';

                card.appendChild(portrait);
                card.appendChild(nameEl);

                const rawDescription = member?.description || member?.shortDescription || '';
                const normalizedDescription = rawDescription
                    .replace(/<[^>]+>/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                const tooltipText = normalizedDescription || 'No description provided.';

                if (tooltipText) {
                    card.setAttribute('aria-label', tooltipText);
                }

                if (tooltipController && typeof tooltipController.show === 'function') {
                    card.addEventListener('mouseenter', (event) => {
                        tooltipController.show(tooltipText, event);
                    });
                    card.addEventListener('mousemove', (event) => {
                        if (typeof tooltipController.move === 'function') {
                            tooltipController.move(event);
                        }
                    });
                    card.addEventListener('mouseleave', () => {
                        tooltipController.hide?.();
                    });
                }

                if (typeof registerNpcContextMenu === 'function' && member.id) {
                    npcDataCache.set(member.id, member);
                    registerNpcContextMenu(card, member);
                }

                container.appendChild(card);
            });
        }

        window.updateChatPlayerPanel = updateChatPlayerPanel;
        window.renderChatPartyPanel = renderChatPartyPanel;

        function processAutoImageElement(element) {
            if (!(element instanceof HTMLElement)) {
                return;
            }

            const entityType = element.dataset.imageEntityType;
            const entityId = element.dataset.imageEntityId;
            if (!entityType || !entityId) {
                return;
            }

            if (element.dataset.imageProcessing === 'true') {
                return;
            }

            const force = element.dataset.imageForce === 'true';
            renderEntityImage({
                element,
                entityType,
                entityId,
                imageId: element.dataset.imageId || null,
                altText: element.dataset.imageAlt || '',
                placeholderIcon: element.dataset.imagePlaceholder || 'üñºÔ∏è',
                placeholderClass: element.dataset.imagePlaceholderClass || 'image-placeholder',
                placeholderMarkup: element.dataset.imagePlaceholderMarkup || null,
                enableLightbox: element.dataset.imageLightbox !== 'false',
                force
            }).finally(() => {
                element.dataset.imageObserved = 'true';
                if (force) {
                    delete element.dataset.imageForce;
                }
            });
        }

        function initializeAutoImagePlaceholders(root = document) {
            if (!root || typeof root.querySelectorAll !== 'function') {
                return;
            }

            const elements = root.querySelectorAll('[data-image-entity-type][data-image-entity-id]');
            elements.forEach(processAutoImageElement);
        }

        initializeAutoImagePlaceholders();

        const autoImageObserver = new MutationObserver(mutations => {
            for (const mutation of mutations) {
                mutation.addedNodes.forEach(node => {
                    if (!(node instanceof HTMLElement)) {
                        return;
                    }

                    if (node.dataset && node.dataset.imageEntityType && node.dataset.imageEntityId) {
                        processAutoImageElement(node);
                    }

                    initializeAutoImagePlaceholders(node);
                });
            }
        });

        try {
            autoImageObserver.observe(document.body, { childList: true, subtree: true });
        } catch (observerError) {
            console.warn('Auto image observer unavailable:', observerError);
        }

        const capitalize = (value) => {
            if (!value) return '';
            const str = String(value).trim();
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        const normalizeThingType = (thing = {}) => {
            const rawType = (thing.thingType || thing.type || thing.category || '').toLowerCase();
            if (!rawType) {
                return 'item';
            }
            if (rawType.includes('scenery')) {
                return 'scenery';
            }
            if (rawType.includes('item')) {
                return 'item';
            }
            return rawType;
        };

        const formatDetailValue = (value) => {
            if (Array.isArray(value)) {
                return value.map(item => escapeHtml(item)).join(', ');
            }
            if (value && typeof value === 'object') {
                try {
                    return escapeHtml(JSON.stringify(value));
                } catch (_) {
                    return escapeHtml(String(value));
                }
            }
            return escapeHtml(value);
        };

        const getAttributeBonuses = (thing = {}) => {
            if (Array.isArray(thing?.attributeBonuses)) {
                return thing.attributeBonuses;
            }
            if (Array.isArray(thing?.metadata?.attributeBonuses)) {
                return thing.metadata.attributeBonuses;
            }
            return [];
        };

        const formatAttributeName = (name = '') => titleCase(name);

        const rarityClassLookup = [
            { key: 'mythic', className: 'rarity-mythic' },
            { key: 'legendary', className: 'rarity-legendary' },
            { key: 'epic', className: 'rarity-epic' },
            { key: 'very rare', className: 'rarity-rare' },
            { key: 'rare', className: 'rarity-rare' },
            { key: 'uncommon', className: 'rarity-uncommon' },
            { key: 'common', className: 'rarity-common' },
            { key: 'artifact', className: 'rarity-artifact' },
            { key: 'unique', className: 'rarity-unique' },
            { key: 'exotic', className: 'rarity-exotic' },
            { key: 'ancient', className: 'rarity-ancient' },
            { key: 'masterwork', className: 'rarity-masterwork' }
        ];

        const availableSlotTypes = window.availableSlotTypes instanceof Set ? window.availableSlotTypes : new Set();
        window.availableSlotTypes = availableSlotTypes;

        const attributeOptions = Array.isArray(window.availableAttributes) ? window.availableAttributes : [];
        window.availableAttributes = attributeOptions;
        let attributeDefinitionsCache = typeof window.attributeDefinitionsMap === 'object' && window.attributeDefinitionsMap
            ? window.attributeDefinitionsMap
            : {};
        window.attributeDefinitionsMap = attributeDefinitionsCache;

        const titleCase = (value) => {
            if (!value) {
                return '';
            }
            return String(value)
                .split(/[\s_-]+/)
                .filter(Boolean)
                .map(part => capitalize(part.toLowerCase()))
                .join(' ');
        };

        const getRarityLabel = (key) => titleCase(key);

        const normalizeSlotType = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value).trim().toLowerCase();
        };

        const formatSlotTypeLabel = (slotType) => titleCase(slotType);

        const addAvailableSlotType = (value) => {
            const normalized = normalizeSlotType(value);
            if (!normalized || normalized === 'n/a' || normalized === 'none') {
                return;
            }
            availableSlotTypes.add(normalized);
        };

        const trackSlotTypeFromThing = (thing = {}) => {
            if (!thing) {
                return;
            }
            const directSlot = typeof thing.slot === 'string' ? thing.slot : null;
            const metadataSlot = typeof thing.metadata?.slot === 'string' ? thing.metadata.slot : null;
            if (directSlot) {
                addAvailableSlotType(directSlot);
            } else if (metadataSlot) {
                addAvailableSlotType(metadataSlot);
            }
        };

        const updateAvailableSlotTypesFromPlayer = (player = {}) => {
            const gearSlotsByType = player && typeof player.gearSlotsByType === 'object' ? player.gearSlotsByType : null;
            if (gearSlotsByType) {
                Object.keys(gearSlotsByType).forEach(addAvailableSlotType);
            }

            const gear = player && typeof player.gear === 'object' ? player.gear : null;
            if (gear) {
                Object.values(gear).forEach(slot => {
                    if (slot && slot.slotType) {
                        addAvailableSlotType(slot.slotType);
                    }
                });
            }

            const inventory = Array.isArray(player.inventory) ? player.inventory : [];
            inventory.forEach(trackSlotTypeFromThing);
        };

        let attributeOptionsLoaded = attributeOptions.length > 0;
        let attributeFetchPromise = null;

        function refreshAllAttributeSelects() {
            if (!thingEditForm) {
                return;
            }
            const selects = thingEditForm.querySelectorAll('.thing-edit-bonus-attribute');
            selects.forEach(select => {
                const currentValue = select?.value || '';
                populateAttributeSelect(select, currentValue);
            });
        }

        function ensureAttributeDefinitions() {
            if (attributeOptionsLoaded) {
                return Promise.resolve(attributeOptions);
            }
            if (attributeFetchPromise) {
                return attributeFetchPromise;
            }

            attributeFetchPromise = (async () => {
                try {
                    const response = await fetch('/api/attributes');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success || !Array.isArray(data.attributes)) {
                        if (!data?.success || !data.attributes) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                        if (data.attributes && typeof data.attributes === 'object') {
                            data.attributes = Object.entries(data.attributes).map(([key, def]) => ({
                                key,
                                label: def?.label || titleCase(key),
                                description: def?.description || '',
                                abbreviation: def?.abbreviation || ''
                            }));
                        }
                        if (!Array.isArray(data.attributes)) {
                            throw new Error(data?.error || 'Failed to load attribute definitions');
                        }
                    }

                    attributeOptions.length = 0;
                    attributeDefinitionsCache = {};
                    window.attributeDefinitionsMap = attributeDefinitionsCache;

                    data.attributes.forEach(attr => {
                        if (!attr || !attr.key) {
                            return;
                        }
                        const key = String(attr.key).trim();
                        if (!key) {
                            return;
                        }
                        const entry = {
                            key,
                            keyLower: key.toLowerCase(),
                            label: attr.label || titleCase(key),
                            description: attr.description || '',
                            abbreviation: attr.abbreviation || ''
                        };
                        attributeOptions.push(entry);
                        attributeDefinitionsCache[key] = entry;
                    });

                    attributeOptionsLoaded = attributeOptions.length > 0;
                    refreshAllAttributeSelects();
                    return attributeOptions;
                } catch (error) {
                    console.warn('Failed to fetch attribute definitions:', error);
                    return [];
                } finally {
                    attributeFetchPromise = null;
                }
            })();

            return attributeFetchPromise;
        }

        let gearSlotTypesLoaded = availableSlotTypes.size > 0;
        let gearSlotTypesPromise = null;

        function ensureGearSlotTypes() {
            if (gearSlotTypesLoaded) {
                return Promise.resolve(availableSlotTypes);
            }
            if (gearSlotTypesPromise) {
                return gearSlotTypesPromise;
            }
            gearSlotTypesPromise = (async () => {
                try {
                    const response = await fetch('/api/gear-slots');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data?.success) {
                        throw new Error(data?.error || 'Failed to load gear slot definitions');
                    }

                    if (Array.isArray(data.slotTypes)) {
                        data.slotTypes.forEach(addAvailableSlotType);
                    }

                    gearSlotTypesLoaded = availableSlotTypes.size > 0;
                    return data;
                } catch (error) {
                    console.warn('Failed to fetch gear slot definitions:', error);
                    return null;
                } finally {
                    gearSlotTypesPromise = null;
                }
            })();
            return gearSlotTypesPromise;
        }

        ensureGearSlotTypes();
        ensureAttributeDefinitions();

        const getRarityClass = (rarity) => {
            if (!rarity && rarity !== 0) {
                return '';
            }
            const normalized = String(rarity).trim().toLowerCase();
            if (!normalized) {
                return '';
            }
            for (const entry of rarityClassLookup) {
                if (normalized === entry.key || normalized.includes(entry.key)) {
                    return entry.className;
                }
            }
            return '';
        };

        const applyRarityClass = (element, rarity) => {
            if (!element) {
                return;
            }
            const rarityClass = getRarityClass(rarity);
            if (rarityClass) {
                element.classList.add(rarityClass);
            }
        };

        const thingDataCache = window.currentThingData instanceof Map ? window.currentThingData : new Map();
        window.currentThingData = thingDataCache;
        const pendingThingRequests = new Map();

        async function fetchThingDetails(thingId) {
            if (!thingId) {
                return null;
            }

            if (thingDataCache.has(thingId)) {
                return thingDataCache.get(thingId);
            }

            if (pendingThingRequests.has(thingId)) {
                return pendingThingRequests.get(thingId);
            }

            const request = fetch(`/api/things/${encodeURIComponent(thingId)}`, {
                cache: 'no-store'
            }).then(async response => {
                try {
                    const data = await response.json();
                    if (data?.success && data.thing) {
                        cacheThingData(data.thing);
                        return data.thing;
                    }
                } catch (error) {
                    console.warn('Failed to parse thing details:', error);
                }
                return null;
            }).catch(error => {
                console.warn(`Failed to load thing ${thingId}:`, error);
                return null;
            }).finally(() => {
                pendingThingRequests.delete(thingId);
            });

            pendingThingRequests.set(thingId, request);
            return request;
        }

        const thingMenuState = { openMenu: null, trigger: null };
        let thingMenuListenersAttached = false;

        function attachThingMenuListeners() {
            if (thingMenuListenersAttached) {
                return;
            }
            document.addEventListener('click', () => {
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeThingContextMenu();
                }
            });
            thingMenuListenersAttached = true;
        }

        function cacheThingData(thing) {
            if (!thing || !thing.id) {
                return;
            }
            thingDataCache.set(thing.id, { ...thing });
            trackSlotTypeFromThing(thing);
        }

        function closeThingContextMenu() {
            if (thingMenuState.openMenu) {
                thingMenuState.openMenu.classList.remove('is-open');
            }
            if (thingMenuState.trigger) {
                thingMenuState.trigger.setAttribute('aria-expanded', 'false');
            }
            thingMenuState.openMenu = null;
            thingMenuState.trigger = null;
        }

        function registerThingContextMenu(card, thing, options = {}) {
            if (!card || !thing || !thing.id) {
                return;
            }

            attachThingMenuListeners();
            cacheThingData(thing);

            card.dataset.thingId = thing.id;

            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'thing-card-menu-button';
            button.setAttribute('aria-haspopup', 'true');
            button.setAttribute('aria-expanded', 'false');
            button.setAttribute('aria-label', `More actions for ${thing.name || 'item'}`);

            const icon = document.createElement('span');
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
            button.appendChild(icon);

            const menu = document.createElement('div');
            menu.className = 'thing-card-menu';

            const editButton = document.createElement('button');
            editButton.type = 'button';
            editButton.className = 'thing-card-menu-item';
            editButton.textContent = 'Edit';
            menu.appendChild(editButton);

            button.addEventListener('click', (event) => {
                event.stopPropagation();
                const wasOpen = thingMenuState.openMenu === menu;
                closeThingContextMenu();
                if (!wasOpen) {
                    menu.classList.add('is-open');
                    button.setAttribute('aria-expanded', 'true');
                    thingMenuState.openMenu = menu;
                    thingMenuState.trigger = button;
                }
            });

            editButton.addEventListener('click', async (event) => {
                event.stopPropagation();
                closeThingContextMenu();
                const cachedThing = thingDataCache.get(thing.id) || thing;
                try {
                    await showThingEditModal(cachedThing, options.context || 'general');
                } catch (error) {
                    console.warn('Failed to open thing editor:', error);
                }
            });

            menu.addEventListener('click', (event) => event.stopPropagation());
            card.addEventListener('click', () => {
                if (thingMenuState.openMenu) {
                    closeThingContextMenu();
                }
            });

            card.appendChild(button);
            card.appendChild(menu);
        }

        const formatThingTooltip = (thing = {}) => {
            const normalizedType = normalizeThingType(thing);

            const metaParts = [];
            if (thing.thingType) {
                const label = thing.thingType === 'scenery' ? 'Scenery' : capitalize(thing.thingType);
                metaParts.push(escapeHtml(label));
            } else if (thing.type) {
                metaParts.push(escapeHtml(capitalize(thing.type)));
            } else if (thing.category) {
                metaParts.push(escapeHtml(capitalize(thing.category)));
            } else if (normalizedType) {
                metaParts.push(escapeHtml(capitalize(normalizedType)));
            }
            if (thing.rarity) {
                metaParts.push(escapeHtml(thing.rarity));
            }
            if (thing.itemTypeDetail) {
                metaParts.push(escapeHtml(thing.itemTypeDetail));
            }

            const detailItems = [];
            if (thing.metadata) {
                const { value, weight, properties } = thing.metadata;
                if (value) {
                    detailItems.push({ label: 'Value', value });
                }
                if (weight) {
                    detailItems.push({ label: 'Weight', value: weight });
                }
                if (properties) {
                    detailItems.push({ label: 'Properties', value: properties });
                }
            }
            if (thing.quantity !== undefined && thing.quantity !== null) {
                detailItems.push({ label: 'Quantity', value: thing.quantity });
            }

            const rarityClass = getRarityClass(thing.rarity);
            const nameClasses = ['tooltip-thing-name'];
            if (rarityClass) {
                nameClasses.push(rarityClass);
            }

            const nameHtml = `<div class="${nameClasses.join(' ')}">${escapeHtml(thing.name || 'Unknown Object')}</div>`;
            const metaHtml = metaParts.length
                ? `<div class="tooltip-thing-meta">${metaParts.join(' ‚Ä¢ ')}</div>`
                : '';
            const descriptionHtml = `<div class="tooltip-thing-description">${escapeHtml(thing.description || 'No description provided.').replace(/\n/g, '<br>')}</div>`;

            const attributeBonuses = getAttributeBonuses(thing).filter(Boolean);
            const bonusesHtml = attributeBonuses.length
                ? `<div class="tooltip-thing-bonuses">
                        <div class="tooltip-thing-bonuses-title">Attribute Bonuses</div>
                        <ul class="tooltip-thing-bonuses-list">
                            ${attributeBonuses.map(bonus => {
                                const attrName = formatAttributeName(bonus?.attribute || bonus?.name || 'Attribute');
                                const rawBonus = Number.parseFloat(bonus?.bonus ?? bonus?.value ?? 0);
                                const formattedBonus = Number.isFinite(rawBonus)
                                    ? (rawBonus > 0 ? `+${rawBonus}` : `${rawBonus}`)
                                    : escapeHtml(bonus?.bonus ?? bonus?.value ?? '0');
                                return `<li class="tooltip-thing-bonus-item"><span class="tooltip-thing-bonus-attr">${escapeHtml(attrName)}</span><span class="tooltip-thing-bonus-value">${escapeHtml(formattedBonus)}</span></li>`;
                            }).join('')}
                        </ul>
                    </div>`
                : '';
            const detailsHtml = detailItems.length
                ? `<div class="tooltip-thing-details">${detailItems.map(item => `
                        <div class="tooltip-thing-detail">
                            <span class="tooltip-thing-detail-label">${escapeHtml(item.label)}</span>
                            <span class="tooltip-thing-detail-value">${formatDetailValue(item.value)}</span>
                        </div>`).join('')}</div>`
                : '';

            const cardClass = normalizedType === 'scenery' ? 'is-scenery' : 'is-item';

            return `
                <div class="tooltip-thing ${cardClass}">
                    ${nameHtml}
                    ${metaHtml}
                    ${descriptionHtml}
                    ${bonusesHtml}
                    ${detailsHtml}
                </div>
            `.trim();
        };

        const npcEditModal = document.getElementById('npcEditModal');
        const npcInventoryModal = document.getElementById('npcInventoryModal');
        const npcViewModal = document.getElementById('npcViewModal');
        const npcModalBackdrop = document.getElementById('npcModalBackdrop');
        const npcEditForm = document.getElementById('npcEditForm');
        const npcEditModalTitle = document.getElementById('npcEditModalTitle');
        const npcEditIdInput = document.getElementById('npcEditId');
        const npcEditNameInput = document.getElementById('npcEditName');
        const npcEditShortDescriptionInput = document.getElementById('npcEditShortDescription');
        const npcEditRaceInput = document.getElementById('npcEditRace');
        const npcEditClassInput = document.getElementById('npcEditClass');
        const npcEditLevelInput = document.getElementById('npcEditLevel');
        const npcEditHealthInput = document.getElementById('npcEditHealth');
        const npcEditMaxHealthInput = document.getElementById('npcEditMaxHealth');
        const npcEditHealthAttributeSelect = document.getElementById('npcEditHealthAttribute');
        const npcEditUnspentInput = document.getElementById('npcEditUnspent');
        const npcEditCurrencyInput = document.getElementById('npcEditCurrency');
        const npcEditExperienceInput = document.getElementById('npcEditExperience');
        const npcEditDescriptionInput = document.getElementById('npcEditDescription');
        const npcEditAttributesContainer = document.getElementById('npcEditAttributes');
        const npcEditSkillsContainer = document.getElementById('npcEditSkills');
        const npcEditAbilitiesContainer = document.getElementById('npcEditAbilities');
        const npcAddSkillBtn = document.getElementById('npcAddSkillBtn');
        const npcAddAbilityBtn = document.getElementById('npcAddAbilityBtn');
        const npcEditCancelBtn = document.getElementById('npcEditCancelBtn');
        const npcEditCloseBtn = document.getElementById('npcEditCloseBtn');
        const npcEditStatus = document.getElementById('npcEditStatus');
        const npcEditSaveBtn = document.getElementById('npcEditSaveBtn');
        const npcInventoryGrid = document.getElementById('npcInventoryGrid');
        const npcInventoryEmpty = document.getElementById('npcInventoryEmpty');
        const npcInventoryCount = document.getElementById('npcInventoryCount');
        const npcInventoryName = document.getElementById('npcInventoryName');
        const npcInventoryCloseBtn = document.getElementById('npcInventoryCloseBtn');
        const npcViewModalTitle = document.getElementById('npcViewModalTitle');
        const npcViewCloseBtn = document.getElementById('npcViewCloseBtn');
        const npcViewImage = document.getElementById('npcViewImage');
        const npcViewName = document.getElementById('npcViewName');
        const npcViewDescription = document.getElementById('npcViewDescription');
        const npcViewClass = document.getElementById('npcViewClass');
        const npcViewRace = document.getElementById('npcViewRace');
        const npcViewLevel = document.getElementById('npcViewLevel');
        const npcViewHealth = document.getElementById('npcViewHealth');
        const npcViewCurrency = document.getElementById('npcViewCurrency');
        const npcViewExperience = document.getElementById('npcViewExperience');
        const npcViewDispositions = document.getElementById('npcViewDispositions');
        const npcViewDispositionsList = document.getElementById('npcViewDispositionsList');
        const npcViewAttributes = document.getElementById('npcViewAttributes');
        const npcViewAttributesEmpty = document.getElementById('npcViewAttributesEmpty');
        const npcViewEquipment = document.getElementById('npcViewEquipment');
        const npcViewEquipmentEmpty = document.getElementById('npcViewEquipmentEmpty');
        const npcViewSkills = document.getElementById('npcViewSkills');
        const npcViewSkillsEmpty = document.getElementById('npcViewSkillsEmpty');
        const npcViewAbilities = document.getElementById('npcViewAbilities');
        const npcViewAbilitiesEmpty = document.getElementById('npcViewAbilitiesEmpty');
        const npcViewStatuses = document.getElementById('npcViewStatuses');
        const npcViewStatusesEmpty = document.getElementById('npcViewStatusesEmpty');
        const thingEditModal = document.getElementById('thingEditModal');
        const thingEditForm = document.getElementById('thingEditForm');
        const thingEditModalTitle = document.getElementById('thingEditModalTitle');
        const thingEditIdInput = document.getElementById('thingEditId');
        const thingEditNameInput = document.getElementById('thingEditName');
        const thingEditTypeSelect = document.getElementById('thingEditType');
        const thingEditRarityInput = document.getElementById('thingEditRarity');
        const thingEditItemDetailInput = document.getElementById('thingEditItemDetail');
        const thingEditSlotSelect = document.getElementById('thingEditSlot');
        const thingEditLevelInput = document.getElementById('thingEditLevel');
        const thingEditImageIdInput = document.getElementById('thingEditImageId');
        const thingEditDescriptionInput = document.getElementById('thingEditDescription');
        const thingMetadataList = document.getElementById('thingEditMetadataList');
        const thingMetadataAddBtn = document.getElementById('thingMetadataAddBtn');
        const thingAttributeBonusesList = document.getElementById('thingEditAttributeBonusesList');
        const thingAttributeBonusAddBtn = document.getElementById('thingAttributeBonusAddBtn');
        const thingCauseEffectNameInput = document.getElementById('thingEditCauseStatusEffectName');
        const thingCauseEffectDescriptionInput = document.getElementById('thingEditCauseStatusEffectDescription');
        const thingCauseEffectDurationInput = document.getElementById('thingEditCauseStatusEffectDuration');
        const thingStatusEffectsList = document.getElementById('thingEditStatusEffectsList');
        const thingStatusEffectAddBtn = document.getElementById('thingStatusEffectAddBtn');
        const thingEditCancelBtn = document.getElementById('thingEditCancelBtn');
        const thingEditCloseBtn = document.getElementById('thingEditCloseBtn');
        const thingEditSaveBtn = document.getElementById('thingEditSaveBtn');
        const thingEditStatus = document.getElementById('thingEditStatus');

        function safeJsonStringify(value, fallback = '') {
            try {
                return JSON.stringify(value, null, 2);
            } catch (_) {
                return fallback;
            }
        }

        function formatThingMetadataValue(value) {
            if (value === undefined || value === null) {
                return '';
            }
            if (typeof value === 'object') {
                return safeJsonStringify(value, '');
            }
            return String(value);
        }

        function extractEditableThingMetadata(thing = {}) {
            if (!thing || typeof thing !== 'object') {
                return {};
            }
            const metadata = thing.metadata && typeof thing.metadata === 'object'
                ? { ...thing.metadata }
                : {};
            delete metadata.slot;
            delete metadata.attributeBonuses;
            delete metadata.causeStatusEffect;
            delete metadata.level;
            delete metadata.relativeLevel;
            delete metadata.location;
            delete metadata.locationId;
            return metadata;
        }

        function createThingMetadataRow(entry = {}) {
            if (!thingMetadataList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-metadata-row';

            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.className = 'thing-edit-metadata-key';
            keyInput.placeholder = 'Key';
            keyInput.autocomplete = 'off';
            keyInput.value = entry.key || '';

            const valueInput = document.createElement('textarea');
            valueInput.className = 'thing-edit-metadata-value';
            valueInput.rows = 1;
            valueInput.placeholder = 'Value (text, number, or JSON)';
            valueInput.value = entry.value !== undefined ? formatThingMetadataValue(entry.value) : '';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(keyInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);

            thingMetadataList.appendChild(row);

            return row;
        }

        function renderThingMetadataEntries(metadata = {}) {
            if (!thingMetadataList) {
                return;
            }
            thingMetadataList.innerHTML = '';
            const entries = metadata && typeof metadata === 'object'
                ? Object.entries(metadata)
                : [];
            if (!entries.length) {
                createThingMetadataRow({});
                return;
            }
            entries.forEach(([key, value]) => {
                createThingMetadataRow({ key, value });
            });
        }

        function collectThingMetadataEntries() {
            if (!thingMetadataList) {
                return {};
            }
            const metadata = {};
            thingMetadataList.querySelectorAll('.thing-edit-metadata-row').forEach(row => {
                const key = row.querySelector('.thing-edit-metadata-key')?.value?.trim();
                if (!key) {
                    return;
                }
                const rawValue = row.querySelector('.thing-edit-metadata-value')?.value ?? '';
                const trimmed = rawValue.trim();
                if (!trimmed) {
                    metadata[key] = '';
                    return;
                }
                let parsed = trimmed;
                try {
                    parsed = JSON.parse(trimmed);
                } catch (_) {
                    parsed = trimmed;
                }
                metadata[key] = parsed;
            });
            return metadata;
        }

        function populateAttributeSelect(selectElement, selectedAttribute = '') {
            if (!selectElement) {
                return;
            }

            const normalized = typeof selectedAttribute === 'string' ? selectedAttribute.trim() : '';
            const normalizedLower = normalized.toLowerCase();

            selectElement.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select attribute';
            selectElement.appendChild(placeholder);

            let hasMatch = false;
            if (Array.isArray(attributeOptions) && attributeOptions.length) {
                attributeOptions.forEach(attr => {
                    if (!attr || !attr.key) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = attr.key;
                    option.textContent = attr.label || titleCase(attr.key);
                    if (attr.description) {
                        option.dataset.description = attr.description;
                    }
                    if (normalizedLower && attr.keyLower === normalizedLower) {
                        option.selected = true;
                        hasMatch = true;
                    }
                    selectElement.appendChild(option);
                });
            }

            if (normalized && !hasMatch) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = titleCase(normalized);
                customOption.selected = true;
                selectElement.appendChild(customOption);
            }
        }

        function createThingAttributeBonusRow(entry = {}) {
            if (!thingAttributeBonusesList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-bonus-row';

            const attributeSelect = document.createElement('select');
            attributeSelect.className = 'thing-edit-bonus-attribute';
            populateAttributeSelect(attributeSelect, entry.attribute || entry.attributeName || '');

            const bonusInput = document.createElement('input');
            bonusInput.type = 'number';
            bonusInput.step = '1';
            bonusInput.className = 'thing-edit-bonus-value';
            bonusInput.placeholder = 'Bonus';
            if (entry.bonus !== undefined && entry.bonus !== null && entry.bonus !== '') {
                const numericBonus = Number(entry.bonus);
                if (!Number.isNaN(numericBonus)) {
                    bonusInput.value = numericBonus;
                }
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(attributeSelect);
            row.appendChild(bonusInput);
            row.appendChild(removeBtn);

            thingAttributeBonusesList.appendChild(row);

            return row;
        }

        function renderThingAttributeBonuses(bonuses = []) {
            if (!thingAttributeBonusesList) {
                return;
            }
            thingAttributeBonusesList.innerHTML = '';
            const entries = Array.isArray(bonuses) ? bonuses : [];
            if (!entries.length) {
                createThingAttributeBonusRow({});
                return;
            }
            entries.forEach(entry => createThingAttributeBonusRow(entry));
        }

        function collectThingAttributeBonuses() {
            if (!thingAttributeBonusesList) {
                return [];
            }
            const bonuses = [];
            thingAttributeBonusesList.querySelectorAll('.thing-edit-bonus-row').forEach(row => {
                const attribute = row.querySelector('.thing-edit-bonus-attribute')?.value?.trim();
                if (!attribute) {
                    return;
                }
                const rawBonus = row.querySelector('.thing-edit-bonus-value')?.value ?? '';
                const numeric = Number.parseFloat(rawBonus);
                bonuses.push({
                    attribute,
                    bonus: Number.isFinite(numeric) ? numeric : 0
                });
            });
            return bonuses;
        }

        function populateThingCauseStatusEffect(effect = null) {
            if (thingCauseEffectNameInput) {
                thingCauseEffectNameInput.value = effect?.name || '';
            }
            if (thingCauseEffectDescriptionInput) {
                thingCauseEffectDescriptionInput.value = effect?.description || effect?.text || '';
            }
            if (thingCauseEffectDurationInput) {
                if (effect && effect.duration !== undefined && effect.duration !== null) {
                    thingCauseEffectDurationInput.value = String(effect.duration);
                } else {
                    thingCauseEffectDurationInput.value = '';
                }
            }
        }

        function collectThingCauseStatusEffect() {
            const name = thingCauseEffectNameInput?.value?.trim();
            const description = thingCauseEffectDescriptionInput?.value?.trim();
            const durationRaw = thingCauseEffectDurationInput?.value?.trim();

            if (!name && !description && !durationRaw) {
                return null;
            }

            const effect = {};
            if (name) {
                effect.name = name;
            }
            if (description) {
                effect.description = description;
            }
            if (durationRaw) {
                const numeric = Number.parseInt(durationRaw, 10);
                effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
            }
            return Object.keys(effect).length ? effect : null;
        }

        function createThingStatusEffectRow(effect = {}) {
            if (!thingStatusEffectsList) {
                return null;
            }

            const row = document.createElement('div');
            row.className = 'thing-edit-row thing-edit-status-row';

            const descriptionInput = document.createElement('textarea');
            descriptionInput.className = 'thing-edit-status-description';
            descriptionInput.rows = 2;
            descriptionInput.placeholder = 'Description';
            descriptionInput.value = effect.description || effect.text || effect.name || '';

            const durationInput = document.createElement('input');
            durationInput.type = 'text';
            durationInput.className = 'thing-edit-status-duration';
            durationInput.placeholder = 'Duration';
            if (effect.duration !== undefined && effect.duration !== null && effect.duration !== '') {
                durationInput.value = String(effect.duration);
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(descriptionInput);
            row.appendChild(durationInput);
            row.appendChild(removeBtn);

            thingStatusEffectsList.appendChild(row);

            return row;
        }

        function renderThingStatusEffects(effects = []) {
            if (!thingStatusEffectsList) {
                return;
            }
            thingStatusEffectsList.innerHTML = '';
            const entries = Array.isArray(effects) ? effects : [];
            if (!entries.length) {
                createThingStatusEffectRow({});
                return;
            }
            entries.forEach(effect => createThingStatusEffectRow(effect));
        }

        function collectThingStatusEffects() {
            if (!thingStatusEffectsList) {
                return [];
            }
            const effects = [];
            thingStatusEffectsList.querySelectorAll('.thing-edit-status-row').forEach(row => {
                const description = row.querySelector('.thing-edit-status-description')?.value?.trim();
                if (!description) {
                    return;
                }
                const durationRaw = row.querySelector('.thing-edit-status-duration')?.value?.trim();
                const effect = { description };
                if (durationRaw) {
                    const numeric = Number.parseInt(durationRaw, 10);
                    effect.duration = Number.isFinite(numeric) ? numeric : durationRaw;
                }
                effects.push(effect);
            });
            return effects;
        }

        function populateThingRarityOptions(selectedRarity = '') {
            if (!thingEditRarityInput) {
                return;
            }

            const normalized = typeof selectedRarity === 'string' ? selectedRarity.trim().toLowerCase() : '';

            thingEditRarityInput.innerHTML = '';

            const unspecifiedOption = document.createElement('option');
            unspecifiedOption.value = '';
            unspecifiedOption.textContent = 'Not specified';
            thingEditRarityInput.appendChild(unspecifiedOption);

            rarityClassLookup.forEach(({ key, className }) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = getRarityLabel(key);
                option.className = className;
                if (normalized && (normalized === key || normalized.includes(key))) {
                    option.selected = true;
                }
                thingEditRarityInput.appendChild(option);
            });

            if (normalized && !rarityClassLookup.some(entry => entry.key === normalized)) {
                const customOption = document.createElement('option');
                customOption.value = normalized;
                customOption.textContent = getRarityLabel(normalized);
                const customClass = getRarityClass(normalized);
                if (customClass) {
                    customOption.className = customClass;
                }
                customOption.selected = true;
                thingEditRarityInput.appendChild(customOption);
            }

            if (!thingEditRarityInput.value && normalized) {
                thingEditRarityInput.value = normalized;
            }
        }

        function populateThingSlotOptions(selectedSlot = '') {
            if (!thingEditSlotSelect) {
                return;
            }

            const normalized = normalizeSlotType(selectedSlot);
            if (normalized) {
                addAvailableSlotType(normalized);
            }
            const slotTypes = Array.from(availableSlotTypes);
            if (normalized && !slotTypes.includes(normalized)) {
                slotTypes.push(normalized);
            }

            slotTypes.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

            thingEditSlotSelect.innerHTML = '';

            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = 'Not equippable';
            thingEditSlotSelect.appendChild(emptyOption);

            slotTypes.forEach(slotType => {
                if (!slotType) {
                    return;
                }
                const option = document.createElement('option');
                option.value = slotType;
                option.textContent = formatSlotTypeLabel(slotType);
                if (slotType === normalized) {
                    option.selected = true;
                }
                thingEditSlotSelect.appendChild(option);
            });

            if (!thingEditSlotSelect.value && normalized) {
                thingEditSlotSelect.value = normalized;
            }
        }

        function populateThingEditForm(thing) {
            if (!thingEditForm) {
                return;
            }

            thingEditForm.reset();

            if (thingEditModalTitle) {
                thingEditModalTitle.textContent = thing?.name ? `Edit ${thing.name}` : 'Edit Item';
            }

            if (thingEditIdInput) {
                thingEditIdInput.value = thing?.id || '';
            }

            if (thingEditNameInput) {
                thingEditNameInput.value = thing?.name || '';
            }

            if (thingEditTypeSelect) {
                const typeValue = (thing?.thingType || thing?.type || 'item').toString().toLowerCase();
                thingEditTypeSelect.value = typeValue === 'scenery' ? 'scenery' : 'item';
            }

            const rarityValue = thing?.rarity || thing?.metadata?.rarity || '';
            populateThingRarityOptions(rarityValue);

            if (thingEditItemDetailInput) {
                const detail = thing?.itemTypeDetail || thing?.itemDetail || '';
                thingEditItemDetailInput.value = detail;
            }

            populateThingSlotOptions(thing?.slot || thing?.metadata?.slot || '');

            if (thingEditLevelInput) {
                const numericLevel = Number.parseInt(thing?.level, 10);
                thingEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }


            if (thingEditImageIdInput) {
                thingEditImageIdInput.value = thing?.imageId || '';
            }

            if (thingEditDescriptionInput) {
                thingEditDescriptionInput.value = thing?.description || '';
            }

            currentThingLockedMetadata = {};
            if (thing && typeof thing.metadata === 'object' && thing.metadata) {
                const locked = {};
                if (thing.metadata.location !== undefined) {
                    locked.location = thing.metadata.location;
                }
                if (thing.metadata.locationId !== undefined) {
                    locked.locationId = thing.metadata.locationId;
                }
                currentThingLockedMetadata = locked;
            }

            const metadata = extractEditableThingMetadata(thing);
            renderThingMetadataEntries(metadata);

            const bonuses = Array.isArray(thing?.attributeBonuses)
                ? thing.attributeBonuses
                : Array.isArray(thing?.metadata?.attributeBonuses)
                    ? thing.metadata.attributeBonuses
                    : [];
            renderThingAttributeBonuses(bonuses);
            refreshAllAttributeSelects();

            const causeStatusEffect = thing?.causeStatusEffect || thing?.metadata?.causeStatusEffect || null;
            populateThingCauseStatusEffect(causeStatusEffect);

            const statusEffects = Array.isArray(thing?.statusEffects) ? thing.statusEffects : [];
            renderThingStatusEffects(statusEffects);

            updateThingEditStatus('');
        }

        async function showThingEditModal(thing, context = 'general') {
            if (!thing || !thing.id || !thingEditModal || !thingEditForm || !npcModalBackdrop) {
                return;
            }

            let resolvedThing = { ...thing };

            const needsDetails = resolvedThing.level === undefined
                || (resolvedThing.metadata && typeof resolvedThing.metadata === 'object'
                    && ('level' in resolvedThing.metadata));

            if (needsDetails) {
                try {
                    const response = await fetch(`/api/things/${encodeURIComponent(thing.id)}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data?.thing) {
                            resolvedThing = { ...data.thing };
                            cacheThingData(resolvedThing);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to fetch full item details:', error);
                }
            }

            await Promise.all([ensureGearSlotTypes(), ensureAttributeDefinitions()]);

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            populateThingEditForm(resolvedThing);

            currentThingEditId = resolvedThing.id;
            currentThingEditContext = context;
            thingEditForm.dataset.thingId = resolvedThing.id;
            thingEditForm.dataset.thingContext = context;

            thingEditModal.removeAttribute('hidden');
            thingEditModal.setAttribute('aria-hidden', 'false');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');

            setTimeout(() => {
                thingEditNameInput?.focus();
            }, 50);
        }

        let currentNpcEditId = null;
        let currentNpcOriginalHealthAttribute = '';
        let currentNpcInventory = [];
        let currentNpcViewId = null;
        let currentThingEditId = null;
        let currentThingEditContext = null;
        let currentThingLockedMetadata = {};

        function isNpcEditorAvailable() {
            return Boolean(npcEditModal && npcEditForm && npcModalBackdrop);
        }

        function formatNpcLabel(value) {
            if (!value) {
                return '';
            }
            return String(value)
                .replace(/_/g, ' ')
                .replace(/\b\w/g, (char) => char.toUpperCase());
        }

        function updateNpcEditStatus(message = '', type = null) {
            if (!npcEditStatus) {
                return;
            }
            npcEditStatus.textContent = message || '';
            npcEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                npcEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                npcEditStatus.classList.add('is-success');
            }
        }

        function updateThingEditStatus(message = '', type = null) {
            if (!thingEditStatus) {
                return;
            }
            thingEditStatus.textContent = message || '';
            thingEditStatus.classList.remove('is-error', 'is-success');
            if (type === 'error') {
                thingEditStatus.classList.add('is-error');
            } else if (type === 'success') {
                thingEditStatus.classList.add('is-success');
            }
        }

        function resolveDefaultHealthAttributeKey(attributeKeys = [], preferred = '') {
            if (!Array.isArray(attributeKeys)) {
                return preferred || '';
            }

            const normalizedPreferred = typeof preferred === 'string' ? preferred.trim().toLowerCase() : '';
            if (normalizedPreferred) {
                const preferredMatch = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === normalizedPreferred);
                if (preferredMatch) {
                    return preferredMatch;
                }
            }

            const preferredList = ['constitution', 'endurance', 'stamina', 'vitality'];
            for (const candidate of preferredList) {
                const match = attributeKeys.find(key => typeof key === 'string' && key.toLowerCase() === candidate);
                if (match) {
                    return match;
                }
            }

            return attributeKeys[0] || '';
        }

        function getNpcAttributesFromInputs() {
            const attributes = {};
            if (!npcEditAttributesContainer) {
                return attributes;
            }
            npcEditAttributesContainer.querySelectorAll('input[data-attribute]').forEach(input => {
                const attributeKey = input.dataset.attribute;
                if (!attributeKey) {
                    return;
                }
                const attributeValue = Number.parseInt(input.value ?? '', 10);
                if (Number.isFinite(attributeValue)) {
                    attributes[attributeKey] = attributeValue;
                }
            });
            return attributes;
        }

        function populateHealthAttributeOptions(attributes = {}, current = '') {
            if (!npcEditHealthAttributeSelect) {
                return;
            }

            const attributeKeys = Object.keys(attributes || {});
            const uniqueKeys = Array.from(new Set(attributeKeys.filter(key => typeof key === 'string' && key.trim().length > 0)));
            const normalizedCurrent = typeof current === 'string' ? current.trim() : '';
            if (normalizedCurrent && !uniqueKeys.some(key => key.toLowerCase() === normalizedCurrent.toLowerCase())) {
                uniqueKeys.push(normalizedCurrent);
            }

            npcEditHealthAttributeSelect.innerHTML = '';

            if (!uniqueKeys.length) {
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'No attributes available';
                npcEditHealthAttributeSelect.appendChild(placeholder);
                npcEditHealthAttributeSelect.disabled = true;
                return;
            }

            npcEditHealthAttributeSelect.disabled = false;
            const resolved = resolveDefaultHealthAttributeKey(uniqueKeys, normalizedCurrent);

            uniqueKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = formatNpcLabel(key);
                if (key === resolved) {
                    option.selected = true;
                }
                npcEditHealthAttributeSelect.appendChild(option);
            });

            npcEditHealthAttributeSelect.value = resolved || '';
        }

        function updateNpcMaxHealth() {
            if (!npcEditMaxHealthInput) {
                return;
            }

            const attributes = getNpcAttributesFromInputs();
            const attributeKeys = Object.keys(attributes);

            const selectedAttribute = npcEditHealthAttributeSelect && !npcEditHealthAttributeSelect.disabled
                ? (npcEditHealthAttributeSelect.value || '').trim()
                : '';

            const resolvedAttribute = selectedAttribute || resolveDefaultHealthAttributeKey(attributeKeys, currentNpcOriginalHealthAttribute);
            const attributeValue = Number.isFinite(attributes[resolvedAttribute]) ? attributes[resolvedAttribute] : 10;

            const levelValue = Number.parseInt(npcEditLevelInput?.value ?? '', 10);
            const level = Number.isFinite(levelValue) && levelValue >= 1 ? levelValue : 1;

            const computed = Math.floor(10 + (attributeValue / 2) * (level + 1));
            npcEditMaxHealthInput.value = Math.max(1, computed);
        }

        function populateNpcAttributes(attributes = {}) {
            if (!npcEditAttributesContainer) {
                return;
            }
            npcEditAttributesContainer.innerHTML = '';
            const entries = Object.entries(attributes || {});
            if (!entries.length) {
                const empty = document.createElement('div');
                empty.className = 'npc-edit-empty';
                empty.textContent = 'No attributes available.';
                npcEditAttributesContainer.appendChild(empty);
                return;
            }
            entries.sort((a, b) => a[0].localeCompare(b[0], undefined, { sensitivity: 'base' }));
            entries.forEach(([key, value]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'npc-attribute-item';

                const label = document.createElement('label');
                const inputId = `npc-attribute-${key.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
                label.setAttribute('for', inputId);
                label.textContent = formatNpcLabel(key);

                const input = document.createElement('input');
                input.type = 'number';
                input.id = inputId;
                input.dataset.attribute = key;
                input.step = '1';
                input.value = Number.isFinite(Number(value)) ? Number(value) : '';

                wrapper.appendChild(label);
                wrapper.appendChild(input);
                input.addEventListener('input', updateNpcMaxHealth);
                input.addEventListener('change', updateNpcMaxHealth);
                npcEditAttributesContainer.appendChild(wrapper);
            });
        }

        function createSkillRow(skill = {}) {
            if (!npcEditSkillsContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-skill-row';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-skill-name';
            nameInput.placeholder = 'Skill name';
            nameInput.autocomplete = 'off';
            nameInput.value = skill.name || '';

            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.className = 'npc-skill-value';
            valueInput.placeholder = 'Value';
            valueInput.step = '1';
            if (skill.value !== undefined && skill.value !== null && skill.value !== '') {
                const numeric = Number(skill.value);
                valueInput.value = Number.isFinite(numeric) ? numeric : '';
            } else {
                valueInput.value = '';
            }

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            row.appendChild(nameInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            npcEditSkillsContainer.appendChild(row);
            return row;
        }

        function populateNpcSkills(skills = {}) {
            if (!npcEditSkillsContainer) {
                return;
            }
            npcEditSkillsContainer.innerHTML = '';
            const entries = Array.isArray(skills)
                ? skills
                : Object.entries(skills || {}).map(([name, value]) => ({ name, value }));
            if (!entries.length) {
                createSkillRow({ name: '', value: '' });
                return;
            }
            entries.sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' }));
            entries.forEach(entry => createSkillRow(entry));
        }

        function createAbilityRow(ability = {}) {
            if (!npcEditAbilitiesContainer) {
                return null;
            }
            const row = document.createElement('div');
            row.className = 'npc-ability-row';

            const main = document.createElement('div');
            main.className = 'npc-ability-row-main';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'npc-ability-name';
            nameInput.placeholder = 'Ability name';
            nameInput.autocomplete = 'off';
            nameInput.value = ability.name || '';

            const typeSelect = document.createElement('select');
            typeSelect.className = 'npc-ability-type';
            ['Passive', 'Active', 'Triggered'].forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = optionValue;
                typeSelect.appendChild(option);
            });
            const normalizedType = typeof ability.type === 'string'
                ? ability.type.trim().toLowerCase()
                : '';
            if (normalizedType) {
                const match = ['passive', 'active', 'triggered'].find(value => value === normalizedType);
                if (match) {
                    typeSelect.value = match.charAt(0).toUpperCase() + match.slice(1);
                }
            }

            const levelInput = document.createElement('input');
            levelInput.type = 'number';
            levelInput.className = 'npc-ability-level';
            levelInput.min = '1';
            levelInput.max = '20';
            levelInput.step = '1';
            const numericLevel = Number.parseInt(ability.level, 10);
            levelInput.value = Number.isFinite(numericLevel) ? numericLevel : 1;

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'npc-edit-remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => row.remove());

            main.appendChild(nameInput);
            main.appendChild(typeSelect);
            main.appendChild(levelInput);
            main.appendChild(removeBtn);

            const descriptionTextarea = document.createElement('textarea');
            descriptionTextarea.className = 'npc-ability-description';
            descriptionTextarea.rows = 2;
            descriptionTextarea.placeholder = 'Description';
            descriptionTextarea.value = ability.description || '';

            row.appendChild(main);
            row.appendChild(descriptionTextarea);
            npcEditAbilitiesContainer.appendChild(row);
            return row;
        }

        function populateNpcAbilities(abilities = []) {
            if (!npcEditAbilitiesContainer) {
                return;
            }
            npcEditAbilitiesContainer.innerHTML = '';
            const entries = Array.isArray(abilities) ? abilities : [];
            if (!entries.length) {
                createAbilityRow({});
                return;
            }
            entries.forEach(ability => createAbilityRow(ability));
        }

        function showNpcEditModal(npc) {
            if (!isNpcEditorAvailable() || !npc) {
                return;
            }

            currentNpcEditId = npc.id || null;
            currentNpcOriginalHealthAttribute = npc.healthAttribute || '';
            if (npcEditModalTitle) {
                npcEditModalTitle.textContent = npc.name ? `Edit ${npc.name}` : 'Edit NPC';
            }

            if (npcEditIdInput) {
                npcEditIdInput.value = npc.id || '';
            }
            if (npcEditNameInput) {
                npcEditNameInput.value = npc.name || '';
            }
            if (npcEditShortDescriptionInput) {
                npcEditShortDescriptionInput.value = npc.shortDescription || '';
            }
            if (npcEditRaceInput) {
                npcEditRaceInput.value = npc.race || '';
            }
            if (npcEditClassInput) {
                npcEditClassInput.value = npc.class || '';
            }
            if (npcEditLevelInput) {
                const numericLevel = Number.parseInt(npc.level, 10);
                npcEditLevelInput.value = Number.isFinite(numericLevel) ? numericLevel : '';
            }
            if (npcEditHealthInput) {
                const numericHealth = Number.parseInt(npc.health, 10);
                npcEditHealthInput.value = Number.isFinite(numericHealth) ? numericHealth : '';
            }
            if (npcEditMaxHealthInput) {
                const numericMax = Number.parseInt(npc.maxHealth, 10);
                npcEditMaxHealthInput.value = Number.isFinite(numericMax) ? numericMax : '';
            }
            if (npcEditUnspentInput) {
                const numericUnspent = Number.parseInt(npc.unspentSkillPoints, 10);
                npcEditUnspentInput.value = Number.isFinite(numericUnspent) ? numericUnspent : 0;
            }
            if (npcEditCurrencyInput) {
                const numericCurrency = Number.parseInt(npc.currency, 10);
                npcEditCurrencyInput.value = Number.isFinite(numericCurrency) && numericCurrency >= 0 ? numericCurrency : '';
            }
            if (npcEditExperienceInput) {
                const numericExperience = Number.parseInt(npc.experience, 10);
                npcEditExperienceInput.value = Number.isFinite(numericExperience) && numericExperience >= 0 ? numericExperience : '';
            }
            if (npcEditDescriptionInput) {
                npcEditDescriptionInput.value = npc.description || '';
            }

            populateNpcAttributes(npc.attributes || {});
            populateNpcSkills(npc.skills || {});
            populateNpcAbilities(Array.isArray(npc.abilities) ? npc.abilities : []);
            populateHealthAttributeOptions(npc.attributes || {}, npc.healthAttribute || '');
            updateNpcMaxHealth();

            updateNpcEditStatus('');

            npcEditForm.dataset.npcId = currentNpcEditId || '';
            npcEditModal.removeAttribute('hidden');
            npcEditModal.setAttribute('aria-hidden', 'false');
            npcEditBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');

            setTimeout(() => {
                npcEditNameInput?.focus();
            }, 50);
        }

        function closeNpcEditModal() {
            if (!isNpcEditorAvailable()) {
                return;
            }
            npcEditModal.setAttribute('aria-hidden', 'true');
            npcEditModal.setAttribute('hidden', '');
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            if (inventoryHidden && viewHidden && thingHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
            currentNpcEditId = null;
            currentNpcOriginalHealthAttribute = '';
            updateNpcEditStatus('');
        }

        function closeNpcInventoryModal() {
            if (!npcInventoryModal) {
                return;
            }
            npcInventoryModal.setAttribute('aria-hidden', 'true');
            npcInventoryModal.setAttribute('hidden', '');
            npcInventoryGrid.innerHTML = '';
            npcInventoryEmpty.style.display = 'block';
            npcInventoryCount.textContent = '0 items';
            currentNpcInventory = [];
            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const viewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            if (editHidden && viewHidden && thingHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeNpcViewModal() {
            if (!npcViewModal) {
                return;
            }
            npcViewModal.setAttribute('aria-hidden', 'true');
            npcViewModal.setAttribute('hidden', '');
            currentNpcViewId = null;
            const inventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const editHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const thingHidden = !thingEditModal || thingEditModal.hasAttribute('hidden');
            if (inventoryHidden && editHidden && thingHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        function closeThingEditModal() {
            if (!thingEditModal) {
                return;
            }
            thingEditModal.setAttribute('aria-hidden', 'true');
            thingEditModal.setAttribute('hidden', '');
            updateThingEditStatus('');
            currentThingEditId = null;
            currentThingEditContext = null;
            if (thingEditForm) {
                thingEditForm.reset();
                delete thingEditForm.dataset.thingId;
                delete thingEditForm.dataset.thingContext;
            }
            if (thingMetadataList) {
                thingMetadataList.innerHTML = '';
            }
            if (thingAttributeBonusesList) {
                thingAttributeBonusesList.innerHTML = '';
            }
            if (thingStatusEffectsList) {
                thingStatusEffectsList.innerHTML = '';
            }
            populateThingCauseStatusEffect(null);
            if (thingEditRarityInput) {
                thingEditRarityInput.innerHTML = '';
            }
            if (thingEditSlotSelect) {
                thingEditSlotSelect.innerHTML = '';
            }
            currentThingLockedMetadata = {};
            const npcModalHidden = !npcEditModal || npcEditModal.hasAttribute('hidden');
            const npcInventoryHidden = !npcInventoryModal || npcInventoryModal.hasAttribute('hidden');
            const npcViewHidden = !npcViewModal || npcViewModal.hasAttribute('hidden');
            if (npcModalHidden && npcInventoryHidden && npcViewHidden) {
                npcModalBackdrop.setAttribute('hidden', '');
                document.body.classList.remove('modal-open');
            }
        }

        if (npcAddSkillBtn) {
            npcAddSkillBtn.addEventListener('click', () => {
                createSkillRow({ name: '', value: '' });
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.scrollTop = npcEditSkillsContainer.scrollHeight;
                }
            });
        }

        if (npcAddAbilityBtn) {
            npcAddAbilityBtn.addEventListener('click', () => {
                createAbilityRow({});
                if (npcEditAbilitiesContainer) {
                    npcEditAbilitiesContainer.scrollTop = npcEditAbilitiesContainer.scrollHeight;
                }
            });
        }

        if (npcEditCancelBtn) {
            npcEditCancelBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcEditCloseBtn) {
            npcEditCloseBtn.addEventListener('click', () => {
                closeNpcEditModal();
            });
        }

        if (npcInventoryCloseBtn) {
            npcInventoryCloseBtn.addEventListener('click', () => {
                closeNpcInventoryModal();
            });
        }

        if (npcViewCloseBtn) {
            npcViewCloseBtn.addEventListener('click', () => {
                closeNpcViewModal();
            });
        }

        if (thingEditCancelBtn) {
            thingEditCancelBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingEditCloseBtn) {
            thingEditCloseBtn.addEventListener('click', () => {
                closeThingEditModal();
            });
        }

        if (thingMetadataAddBtn) {
            thingMetadataAddBtn.addEventListener('click', () => {
                const row = createThingMetadataRow({});
                row?.querySelector('.thing-edit-metadata-key')?.focus();
            });
        }

        if (thingAttributeBonusAddBtn) {
            thingAttributeBonusAddBtn.addEventListener('click', async () => {
                await ensureAttributeDefinitions();
                const row = createThingAttributeBonusRow({});
                row?.querySelector('.thing-edit-bonus-attribute')?.focus();
            });
        }

        if (thingStatusEffectAddBtn) {
            thingStatusEffectAddBtn.addEventListener('click', () => {
                const row = createThingStatusEffectRow({});
                row?.querySelector('.thing-edit-status-description')?.focus();
            });
        }

        if (npcModalBackdrop) {
            npcModalBackdrop.addEventListener('click', (event) => {
                if (event.target === npcModalBackdrop) {
                    if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                        closeThingEditModal();
                    } else if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                        closeNpcViewModal();
                    } else if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                        closeNpcInventoryModal();
                    } else if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                        closeNpcEditModal();
                    }
                }
            });
        }

        if (npcEditModal) {
            npcEditModal.addEventListener('click', (event) => {
                if (event.target === npcEditModal) {
                    closeNpcEditModal();
                }
            });
        }

        if (npcInventoryModal) {
            npcInventoryModal.addEventListener('click', (event) => {
                if (event.target === npcInventoryModal) {
                    closeNpcInventoryModal();
                }
            });
        }

        if (npcViewModal) {
            npcViewModal.addEventListener('click', (event) => {
                if (event.target === npcViewModal) {
                    closeNpcViewModal();
                }
            });
        }

        if (thingEditModal) {
            thingEditModal.addEventListener('click', (event) => {
                if (event.target === thingEditModal) {
                    closeThingEditModal();
                }
            });
        }

        if (npcEditLevelInput) {
            npcEditLevelInput.addEventListener('input', updateNpcMaxHealth);
            npcEditLevelInput.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditHealthAttributeSelect) {
            npcEditHealthAttributeSelect.addEventListener('change', updateNpcMaxHealth);
        }

        if (npcEditForm) {
            npcEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                if (!currentNpcEditId) {
                    updateNpcEditStatus('No NPC selected.', 'error');
                    return;
                }

                const payload = {};

                const trimmedName = npcEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }
                if (npcEditDescriptionInput) {
                    payload.description = npcEditDescriptionInput.value ?? '';
                }
                if (npcEditShortDescriptionInput) {
                    payload.shortDescription = npcEditShortDescriptionInput.value ?? '';
                }
                if (npcEditRaceInput) {
                    payload.race = npcEditRaceInput.value ?? '';
                }
                if (npcEditClassInput) {
                    payload.class = npcEditClassInput.value ?? '';
                }

                const parsedLevel = Number.parseInt(npcEditLevelInput?.value ?? '', 10);
                if (Number.isFinite(parsedLevel)) {
                    payload.level = parsedLevel;
                }

                const parsedHealth = Number.parseInt(npcEditHealthInput?.value ?? '', 10);
                if (Number.isFinite(parsedHealth)) {
                    payload.health = parsedHealth;
                }

                const parsedUnspent = Number.parseInt(npcEditUnspentInput?.value ?? '', 10);
                if (Number.isFinite(parsedUnspent) && parsedUnspent >= 0) {
                    payload.unspentSkillPoints = parsedUnspent;
                }

                const parsedCurrency = Number.parseInt(npcEditCurrencyInput?.value ?? '', 10);
                if (Number.isFinite(parsedCurrency) && parsedCurrency >= 0) {
                    payload.currency = parsedCurrency;
                }

                const parsedExperience = Number.parseInt(npcEditExperienceInput?.value ?? '', 10);
                if (Number.isFinite(parsedExperience) && parsedExperience >= 0) {
                    payload.experience = parsedExperience;
                }

                const attributes = getNpcAttributesFromInputs();
                payload.attributes = attributes;

                const selectedHealthAttribute = npcEditHealthAttributeSelect && !npcEditHealthAttributeSelect.disabled
                    ? (npcEditHealthAttributeSelect.value || '').trim()
                    : '';
                if (selectedHealthAttribute) {
                    payload.healthAttribute = selectedHealthAttribute;
                }

                const skills = {};
                if (npcEditSkillsContainer) {
                    npcEditSkillsContainer.querySelectorAll('.npc-skill-row').forEach(row => {
                        const name = row.querySelector('.npc-skill-name')?.value?.trim();
                        if (!name) {
                            return;
                        }
                        const valueInput = row.querySelector('.npc-skill-value');
                        const numeric = Number.parseInt(valueInput?.value ?? '', 10);
                        skills[name] = Number.isFinite(numeric) ? numeric : 0;
                    });
                }
                payload.skills = skills;

                const abilityEntries = [];
                if (npcEditAbilitiesContainer) {
                    npcEditAbilitiesContainer.querySelectorAll('.npc-ability-row').forEach(row => {
                        const abilityName = row.querySelector('.npc-ability-name')?.value?.trim();
                        if (!abilityName) {
                            return;
                        }
                        const abilityType = row.querySelector('.npc-ability-type')?.value || 'Passive';
                        const abilityLevel = Number.parseInt(row.querySelector('.npc-ability-level')?.value ?? '', 10);
                        const abilityDescription = row.querySelector('.npc-ability-description')?.value?.trim() || '';
                        abilityEntries.push({
                            name: abilityName,
                            type: abilityType,
                            level: Number.isFinite(abilityLevel) ? abilityLevel : 1,
                            description: abilityDescription
                        });
                    });
                }
                payload.abilities = abilityEntries;

                try {
                    updateNpcEditStatus('Saving changes...');
                    if (npcEditSaveBtn) {
                        npcEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/npcs/${encodeURIComponent(currentNpcEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update NPC');
                    }

                    updateNpcEditStatus('Changes saved.', 'success');

                    if (typeof window.loadCurrentLocation === 'function') {
                        await window.loadCurrentLocation();
                    }
                    window.refreshParty?.();

                    closeNpcEditModal();
                } catch (error) {
                    updateNpcEditStatus(error?.message || 'Failed to update NPC.', 'error');
                } finally {
                    if (npcEditSaveBtn) {
                        npcEditSaveBtn.disabled = false;
                    }
                }
            });
        }

        if (thingEditForm) {
            thingEditForm.addEventListener('submit', async (event) => {
                event.preventDefault();

                if (!currentThingEditId) {
                    updateThingEditStatus('No item selected.', 'error');
                    return;
                }

                updateThingEditStatus('');

                const payload = {};

                const trimmedName = thingEditNameInput?.value?.trim();
                if (trimmedName) {
                    payload.name = trimmedName;
                }

                if (thingEditDescriptionInput) {
                    payload.description = thingEditDescriptionInput.value ?? '';
                }

                if (thingEditTypeSelect) {
                    const typeValue = (thingEditTypeSelect.value || '').toLowerCase();
                    payload.thingType = typeValue === 'scenery' ? 'scenery' : 'item';
                }

                if (thingEditRarityInput) {
                    const rarityKey = thingEditRarityInput.value?.trim();
                    payload.rarity = rarityKey ? getRarityLabel(rarityKey) : null;
                }

                if (thingEditItemDetailInput) {
                    const detailValue = thingEditItemDetailInput.value?.trim();
                    payload.itemTypeDetail = detailValue || null;
                }

                if (thingEditSlotSelect) {
                    const slotValue = normalizeSlotType(thingEditSlotSelect.value);
                    if (slotValue) {
                        addAvailableSlotType(slotValue);
                    }
                    payload.slot = slotValue || null;
                }

                if (thingEditLevelInput) {
                    const parsedLevel = Number.parseInt(thingEditLevelInput.value ?? '', 10);
                    payload.level = Number.isFinite(parsedLevel) ? parsedLevel : null;
                }

                if (thingEditImageIdInput) {
                    const imageValue = thingEditImageIdInput.value?.trim();
                    payload.imageId = imageValue || null;
                }

                const metadataValue = collectThingMetadataEntries();
                const finalMetadata = { ...metadataValue };
                if (currentThingLockedMetadata && typeof currentThingLockedMetadata === 'object') {
                    Object.entries(currentThingLockedMetadata).forEach(([key, value]) => {
                        if (value !== undefined) {
                            finalMetadata[key] = value;
                        }
                    });
                }
                payload.metadata = finalMetadata;

                const attributeBonusesValue = collectThingAttributeBonuses();
                payload.attributeBonuses = attributeBonusesValue;

                const causeStatusEffectValue = collectThingCauseStatusEffect();
                payload.causeStatusEffect = causeStatusEffectValue;

                const statusEffectsValue = collectThingStatusEffects();
                payload.statusEffects = statusEffectsValue;

                if (!payload.thingType) {
                    payload.thingType = 'item';
                }

                try {
                    updateThingEditStatus('Saving changes...');
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = true;
                    }

                    const response = await fetch(`/api/things/${encodeURIComponent(currentThingEditId)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    let result = {};
                    try {
                        result = await response.json();
                    } catch (_) {
                        // ignore JSON parse failures; handled below
                    }

                    if (!response.ok || !result?.success) {
                        throw new Error(result?.error || 'Failed to update item.');
                    }

                    const updatedThing = result?.thing || { ...thingDataCache.get(currentThingEditId), ...payload, id: currentThingEditId };
                    cacheThingData(updatedThing);

                    if (currentThingEditContext === 'npc-inventory' && Array.isArray(currentNpcInventory)) {
                        currentNpcInventory = currentNpcInventory.map(item => item && item.id === updatedThing.id ? updatedThing : item);
                        renderNpcInventory(currentNpcInventory);
                    }

                    updateThingEditStatus('Changes saved.', 'success');

                    try {
                        if (currentThingEditContext === 'player-inventory') {
                            if (typeof window.refreshInventory === 'function') {
                                await window.refreshInventory();
                            }
                        } else if (currentThingEditContext === 'location') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else if (currentThingEditContext === 'npc-inventory') {
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        } else {
                            if (typeof window.refreshInventory === 'function') {
                                await window.refreshInventory();
                            }
                            if (typeof window.loadCurrentLocation === 'function') {
                                await window.loadCurrentLocation();
                            }
                        }
                        window.refreshParty?.();
                    } catch (refreshError) {
                        console.warn('Failed to refresh displays after item update:', refreshError);
                    }

                    closeThingEditModal();
                } catch (error) {
                    updateThingEditStatus(error?.message || 'Failed to update item.', 'error');
                } finally {
                    if (thingEditSaveBtn) {
                        thingEditSaveBtn.disabled = false;
                    }
                }
            });
        }

        function bindThingTooltip(element, thing) {
            if (!element || !thing) {
                return;
            }

            element.addEventListener('mouseenter', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.show === 'function') {
                    const description = thing.description || 'No description provided.';
                    const fallbackTooltip = `<div class="tooltip-thing is-item"><div class="tooltip-thing-description">${escapeHtml(description)}</div></div>`;
                    const tooltipContent = formatThingTooltip(thing) || fallbackTooltip;
                    window.floatingTooltipController.show(tooltipContent, event, { allowHTML: true });
                }
            });

            element.addEventListener('mousemove', (event) => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.move === 'function') {
                    window.floatingTooltipController.move(event);
                }
            });

            element.addEventListener('mouseleave', () => {
                if (window.floatingTooltipController && typeof window.floatingTooltipController.hide === 'function') {
                    window.floatingTooltipController.hide();
                }
            });
        }

        function renderNpcInventory(items = []) {
            if (!npcInventoryGrid || !npcInventoryEmpty || !npcInventoryCount) {
                return;
            }

            const safeItems = Array.isArray(items) ? items : [];
            npcInventoryGrid.innerHTML = '';
            npcInventoryCount.textContent = `${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`;
            npcInventoryEmpty.style.display = safeItems.length ? 'none' : 'block';
            npcInventoryGrid.style.display = safeItems.length ? 'flex' : 'none';

            safeItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'location-entity-card inventory-card';

                const icon = document.createElement('div');
                icon.className = 'inventory-icon';
                renderEntityImage({
                    element: icon,
                    entityType: 'thing',
                    entityId: item.id,
                    imageId: item.imageId || null,
                    altText: item.name || 'Inventory item',
                    placeholderIcon: item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ',
                    placeholderClass: 'location-entity-placeholder'
                });

                const name = document.createElement('div');
                name.className = 'inventory-name';
                name.textContent = item.name || 'Unknown Item';
                applyRarityClass(name, item.rarity);

                card.appendChild(icon);
                card.appendChild(name);

                registerThingContextMenu(card, item, { context: 'npc-inventory' });

                bindThingTooltip(card, item);

                npcInventoryGrid.appendChild(card);
            });
        }

        function showNpcInventoryModal(npc) {
            if (!npc || !npcInventoryModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            npcInventoryModal.setAttribute('aria-hidden', 'false');
            npcInventoryModal.removeAttribute('hidden');
            npcModalBackdrop.removeAttribute('hidden');
            document.body.classList.add('modal-open');

            npcInventoryName.textContent = npc.name || 'Character';
            const items = Array.isArray(npc.inventory) ? npc.inventory : [];
            currentNpcInventory = items;
            renderNpcInventory(items);
        }

        function formatTagValue(label, value) {
            if (value === undefined || value === null || value === '') {
                return '';
            }
            return `${label}: ${value}`;
        }

        function renderDefinitionList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            if (!Array.isArray(entries) || entries.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }
            entries.forEach(({ term, detail }) => {
                const dt = document.createElement('dt');
                dt.textContent = term;
                const dd = document.createElement('dd');
                dd.textContent = detail;
                container.appendChild(dt);
                container.appendChild(dd);
            });
        }

        function renderEquipmentList(container, emptyState, entries = []) {
            if (!container) {
                return;
            }

            container.innerHTML = '';
            const safeEntries = Array.isArray(entries) ? entries.filter(Boolean) : [];

            if (!safeEntries.length) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }

            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            safeEntries.forEach(entry => {
                const row = document.createElement('div');
                row.className = 'npc-view-equipment-row';

                const slotContainer = document.createElement('div');
                slotContainer.className = 'npc-view-equipment-slot';
                const slotName = document.createElement('div');
                slotName.className = 'npc-view-equipment-slot-name';
                slotName.textContent = entry.slotLabel || 'Slot';
                slotContainer.appendChild(slotName);

                if (entry.slotTypeLabel && entry.slotTypeLabel !== entry.slotLabel) {
                    const slotType = document.createElement('div');
                    slotType.className = 'npc-view-equipment-slot-type';
                    slotType.textContent = entry.slotTypeLabel;
                    slotContainer.appendChild(slotType);
                }

                const itemContainer = document.createElement('div');
                itemContainer.className = 'npc-view-equipment-item';

                if (entry.item && typeof entry.item === 'object') {
                    const card = document.createElement('div');
                    card.className = 'npc-view-equipment-item-card';

                    const icon = document.createElement('div');
                    icon.className = 'npc-view-equipment-icon';
                    const placeholderIcon = entry.item.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                    renderEntityImage({
                        element: icon,
                        entityType: 'thing',
                        entityId: entry.item.id || null,
                        imageId: entry.item.imageId || null,
                        altText: entry.item.name || 'Equipped item',
                        placeholderIcon,
                        placeholderClass: 'npc-view-equipment-icon-placeholder'
                    });

                    const textWrapper = document.createElement('div');
                    textWrapper.className = 'npc-view-equipment-text';
                    const name = document.createElement('div');
                    name.className = 'npc-view-equipment-name';
                    name.textContent = entry.item.name || 'Unknown Item';
                    applyRarityClass(name, entry.item.rarity);
                    textWrapper.appendChild(name);

                    card.appendChild(icon);
                    card.appendChild(textWrapper);

                    if (entry.item && entry.item.id) {
                        registerThingContextMenu(card, entry.item, { context: 'npc-equipment' });
                    }

                    bindThingTooltip(card, entry.item);
                    itemContainer.appendChild(card);
                } else {
                    const empty = document.createElement('span');
                    empty.className = 'npc-view-equipment-empty';
                    empty.textContent = 'Empty';
                    itemContainer.appendChild(empty);
                }

                row.appendChild(slotContainer);
                row.appendChild(itemContainer);
                container.appendChild(row);
            });
        }

        function renderList(container, emptyState, items = [], options = {}) {
            if (!container) {
                return;
            }
            container.innerHTML = '';
            const safeItems = Array.isArray(items) ? items.filter(Boolean) : [];
            if (safeItems.length === 0) {
                if (emptyState) {
                    emptyState.removeAttribute('hidden');
                }
                container.setAttribute('hidden', '');
                return;
            }
            container.removeAttribute('hidden');
            if (emptyState) {
                emptyState.setAttribute('hidden', '');
            }

            const { allowHTML = false } = options;
            safeItems.forEach(item => {
                const li = document.createElement('li');
                if (allowHTML) {
                    li.innerHTML = item;
                } else {
                    li.textContent = item;
                }
                container.appendChild(li);
            });
        }

        function showNpcViewModal(npc) {
            if (!npc || !npcViewModal || !npcModalBackdrop) {
                return;
            }

            try {
                window.floatingTooltipController?.hide?.();
            } catch (_) {}

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            const latestNpc = npc && npc.id ? (npcDataCache.get(npc.id) || npc) : npc;
            currentNpcViewId = latestNpc?.id || npc?.id || null;

            npcModalBackdrop.removeAttribute('hidden');
            npcViewModal.removeAttribute('hidden');
            npcViewModal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');

            const name = latestNpc?.name || 'Unknown Character';
            const description = latestNpc?.description || latestNpc?.shortDescription || 'No description available.';
            const resolveTagValue = (...values) => {
                for (const value of values) {
                    if (value === undefined || value === null) {
                        continue;
                    }
                    if (typeof value === 'string') {
                        const trimmed = value.trim();
                        if (trimmed) {
                            return trimmed;
                        }
                    } else if (value !== '') {
                        return value;
                    }
                }
                return null;
            };
            const classLabel = resolveTagValue(latestNpc?.class, latestNpc?.className, latestNpc?.classLabel) || 'Unknown';
            const raceLabel = resolveTagValue(latestNpc?.race, latestNpc?.species, latestNpc?.raceName) || 'Unknown';
            const levelValue = Number.isFinite(Number(latestNpc?.level)) ? Number(latestNpc.level) : null;
            const healthValue = Number.isFinite(Number(latestNpc?.health)) ? Number(latestNpc.health) : null;
            const maxHealthValue = Number.isFinite(Number(latestNpc?.maxHealth)) ? Number(latestNpc.maxHealth) : null;
            const parseNonNegativeInt = (value) => {
                const parsed = Number.parseInt(value, 10);
                return Number.isFinite(parsed) && parsed >= 0 ? parsed : null;
            };

            if (npcViewModalTitle) {
                npcViewModalTitle.textContent = latestNpc?.name ? `${latestNpc.name} ¬∑ Overview` : 'Character Overview';
            }

            if (npcViewName) {
                npcViewName.textContent = name;
            }
            if (npcViewDescription) {
                npcViewDescription.textContent = description;
            }

            const updateTag = (element, label, value) => {
                if (!element) {
                    return;
                }
                if (value === undefined || value === null || value === '') {
                    element.textContent = '';
                    element.setAttribute('hidden', '');
                    return;
                }
                element.textContent = formatTagValue(label, value);
                element.removeAttribute('hidden');
            };

            updateTag(npcViewClass, 'Class', classLabel);
            updateTag(npcViewRace, 'Race', raceLabel);
            updateTag(npcViewLevel, 'Level', levelValue);

            if (npcViewHealth) {
                if (healthValue === null && maxHealthValue === null) {
                    npcViewHealth.textContent = '';
                    npcViewHealth.setAttribute('hidden', '');
                } else {
                    if (healthValue !== null && maxHealthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}/${maxHealthValue}`;
                    } else if (healthValue !== null) {
                        npcViewHealth.textContent = `${healthValue}`;
                    } else {
                        npcViewHealth.textContent = `${maxHealthValue}`;
                    }
                    npcViewHealth.removeAttribute('hidden');
                }
            }

            if (npcViewCurrency) {
                const currencyValue = parseNonNegativeInt(latestNpc?.currency);
                if (currencyValue === null) {
                    npcViewCurrency.textContent = '';
                    npcViewCurrency.setAttribute('hidden', '');
                } else {
                    const currencyLabel = (() => {
                        const setting = window.currentSetting || {};
                        const label = typeof setting.currencyNamePlural === 'string' ? setting.currencyNamePlural.trim() : '';
                        return label || 'coins';
                    })();
                    npcViewCurrency.textContent = `Currency: ${currencyValue} ${currencyLabel}`;
                    npcViewCurrency.removeAttribute('hidden');
                }
            }

            if (npcViewExperience) {
                const experienceValue = parseNonNegativeInt(latestNpc?.experience);
                if (experienceValue === null) {
                    npcViewExperience.textContent = '';
                    npcViewExperience.setAttribute('hidden', '');
                } else {
                    npcViewExperience.textContent = `Experience: ${experienceValue}`;
                    npcViewExperience.removeAttribute('hidden');
                }
            }

            const dispositions = Array.isArray(latestNpc?.dispositionsTowardsPlayer)
                ? latestNpc.dispositionsTowardsPlayer.filter(entry => entry && entry.type)
                : [];
            if (npcViewDispositions && npcViewDispositionsList) {
                if (!dispositions.length) {
                    npcViewDispositions.setAttribute('hidden', '');
                    npcViewDispositions.removeAttribute('open');
                    npcViewDispositionsList.innerHTML = '';
                } else {
                    npcViewDispositions.removeAttribute('hidden');
                    npcViewDispositions.open = false;
                    npcViewDispositionsList.innerHTML = '';
                    dispositions.forEach(entry => {
                        const chip = document.createElement('span');
                        chip.className = 'npc-view-disposition-chip';
                        const numericValue = Number(entry.value);
                        const formattedValue = Number.isFinite(numericValue)
                            ? ` (${numericValue > 0 ? '+' : ''}${numericValue})`
                            : '';
                        chip.textContent = `${entry.type}: ${entry.intensityName || 'neutral'}${formattedValue}`;
                        npcViewDispositionsList.appendChild(chip);
                    });
                }
            }

            if (npcViewImage) {
                renderEntityImage({
                    element: npcViewImage,
                    entityType: latestNpc?.isNPC ? 'npc' : 'player',
                    entityId: latestNpc?.id || null,
                    imageId: latestNpc?.imageId || null,
                    altText: `${name} portrait`,
                    placeholderIcon: 'üé≠',
                    placeholderClass: 'npc-view-image-placeholder'
                });
            }

            const attributeEntries = [];
            if (latestNpc?.attributeInfo && typeof latestNpc.attributeInfo === 'object') {
                for (const [key, info] of Object.entries(latestNpc.attributeInfo)) {
                    const label = info?.label || formatAttributeName(key);
                    const value = Number.isFinite(Number(info?.value)) ? Number(info.value) : info?.value;
                    const modifier = Number.isFinite(Number(info?.modifier)) ? Number(info.modifier) : null;
                    const parts = [];
                    if (value !== undefined && value !== null) {
                        parts.push(value);
                    }
                    if (modifier !== null) {
                        parts.push(`${modifier >= 0 ? '+' : ''}${modifier}`);
                    }
                    attributeEntries.push({ term: label, detail: parts.join(' ') || '‚Äî' });
                }
            } else if (latestNpc?.attributes && typeof latestNpc.attributes === 'object') {
                for (const [key, value] of Object.entries(latestNpc.attributes)) {
                    const label = formatAttributeName(key);
                    const detail = Number.isFinite(Number(value)) ? Number(value) : (value ?? '‚Äî');
                    attributeEntries.push({ term: label, detail });
                }
            }
            attributeEntries.sort((a, b) => a.term.localeCompare(b.term));
            renderDefinitionList(npcViewAttributes, npcViewAttributesEmpty, attributeEntries);

            const inventoryItems = Array.isArray(latestNpc?.inventory) ? latestNpc.inventory : [];
            const inventoryMap = new Map();
            inventoryItems.forEach(item => {
                if (item && item.id) {
                    inventoryMap.set(item.id, item);
                }
            });

            const equipmentEntries = [];
            if (latestNpc?.gear && typeof latestNpc.gear === 'object') {
                for (const [slotName, slotData] of Object.entries(latestNpc.gear)) {
                    if (!slotName && !slotData?.slotType) {
                        continue;
                    }

                    const slotTypeLabel = slotData?.slotType ? formatSlotTypeLabel(slotData.slotType) : '';
                    const resolvedSlotName = typeof slotName === 'string' && slotName.trim()
                        ? slotName.trim()
                        : '';
                    const slotLabel = resolvedSlotName || (slotTypeLabel ? `${slotTypeLabel} Slot` : 'Slot');

                    let resolvedItem = null;
                    if (slotData && slotData.itemId) {
                        resolvedItem = inventoryMap.get(slotData.itemId) || null;
                    }
                    if (!resolvedItem && slotData && typeof slotData.item === 'object') {
                        resolvedItem = slotData.item;
                    }
                    if (!resolvedItem && slotData && (slotData.itemName || slotData.itemId)) {
                        resolvedItem = {
                            id: slotData.itemId || null,
                            name: slotData.itemName || slotData.itemId || 'Unknown Item',
                            rarity: slotData.itemRarity || null,
                            thingType: slotData.itemType || null
                        };
                    }

                    equipmentEntries.push({
                        slotLabel,
                        slotTypeLabel,
                        item: resolvedItem
                    });
                }
            }
            equipmentEntries.sort((a, b) => a.slotLabel.localeCompare(b.slotLabel));
            renderEquipmentList(npcViewEquipment, npcViewEquipmentEmpty, equipmentEntries);

            const skillData = [];
            if (latestNpc?.skills) {
                if (Array.isArray(latestNpc.skills)) {
                    latestNpc.skills.forEach(entry => {
                        if (!entry) return;
                        if (typeof entry === 'string') {
                            skillData.push({ name: entry, rank: null });
                        } else if (entry.name) {
                            const rankValue = Number.isFinite(Number(entry.rank)) ? Number(entry.rank) : null;
                            skillData.push({ name: entry.name, rank: rankValue });
                        }
                    });
                } else if (latestNpc.skills && typeof latestNpc.skills === 'object') {
                    for (const [skillName, rank] of Object.entries(latestNpc.skills)) {
                        const rankValue = Number.isFinite(Number(rank)) ? Number(rank) : null;
                        skillData.push({ name: skillName, rank: rankValue });
                    }
                }
            }
            skillData.sort((a, b) => a.name.localeCompare(b.name));
            if (npcViewSkills) {
                npcViewSkills.innerHTML = '';
                if (!skillData.length) {
                    npcViewSkills.setAttribute('hidden', '');
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.removeAttribute('hidden');
                    }
                } else {
                    if (npcViewSkillsEmpty) {
                        npcViewSkillsEmpty.setAttribute('hidden', '');
                    }
                    const table = document.createElement('table');
                    table.className = 'npc-view-skills-table';
                    const tbody = document.createElement('tbody');
                    table.appendChild(tbody);

                    skillData.forEach((entry, index) => {
                        const row = document.createElement('tr');
                        if ((index % 2) === 1) {
                            row.classList.add('is-alt');
                        }

                        const nameCell = document.createElement('td');
                        nameCell.className = 'npc-view-skill-name';
                        nameCell.textContent = entry.name || 'Unknown Skill';

                        const rankCell = document.createElement('td');
                        rankCell.className = 'npc-view-skill-rank';
                        if (entry.rank !== null && entry.rank !== undefined) {
                            const numericRank = Number(entry.rank);
                            rankCell.textContent = Number.isFinite(numericRank)
                                ? `${numericRank > 0 ? '+' : ''}${numericRank}`
                                : `${entry.rank}`;
                        } else {
                            rankCell.textContent = '‚Äî';
                        }

                        row.appendChild(nameCell);
                        row.appendChild(rankCell);
                        tbody.appendChild(row);
                    });

                    npcViewSkills.appendChild(table);
                    npcViewSkills.removeAttribute('hidden');
                }
            }

            const abilityEntries = [];
            if (Array.isArray(latestNpc?.abilities)) {
                latestNpc.abilities.forEach(ability => {
                    if (!ability) return;
                    const label = ability.name || 'Ability';
                    const typeSuffix = ability.type ? ` (${ability.type})` : '';
                    const descriptionText = ability.description || ability.text || '';
                    const entry = `<strong>${escapeHtml(label)}${escapeHtml(typeSuffix)}</strong>${descriptionText ? `<span class="npc-view-list-description">${escapeHtml(descriptionText)}</span>` : ''}`;
                    abilityEntries.push(entry);
                });
            }
            renderList(npcViewAbilities, npcViewAbilitiesEmpty, abilityEntries, { allowHTML: true });

            const statusEntries = [];
            if (Array.isArray(latestNpc?.statusEffects)) {
                latestNpc.statusEffects.forEach(effect => {
                    if (!effect) return;
                    if (typeof effect === 'string') {
                        statusEntries.push(effect);
                        return;
                    }
                    const descriptionText = effect.description || effect.text || effect.name || '';
                    if (!descriptionText) {
                        return;
                    }
                    const durationText = Number.isFinite(Number(effect.duration))
                        ? ` (Duration ${Number(effect.duration)})`
                        : '';
                    statusEntries.push(`${descriptionText}${durationText}`);
                });
            }
            renderList(npcViewStatuses, npcViewStatusesEmpty, statusEntries);
        }

        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') {
                return;
            }

            if (thingEditModal && !thingEditModal.hasAttribute('hidden')) {
                event.preventDefault();
                closeThingEditModal();
                return;
            }

            if (npcViewModal && !npcViewModal.hasAttribute('hidden')) {
                event.preventDefault();
                closeNpcViewModal();
                return;
            }

            if (npcInventoryModal && !npcInventoryModal.hasAttribute('hidden')) {
                event.preventDefault();
                closeNpcInventoryModal();
                return;
            }

            if (npcEditModal && !npcEditModal.hasAttribute('hidden')) {
                event.preventDefault();
                closeNpcEditModal();
            }
        });

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            const hashPrefix = 'tab-';

            const activateTab = (tabName) => {
                if (!tabName) return;
                const targetButton = Array.from(tabButtons).find(btn => btn.dataset.tab === tabName);
                const targetPanel = document.getElementById(`tab-${tabName}`);
                if (!targetButton || !targetPanel) return;

                tabButtons.forEach(btn => {
                    const isActive = btn === targetButton;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                });

                tabPanels.forEach(panel => {
                    const isActive = panel === targetPanel;
                    panel.toggleAttribute('hidden', !isActive);
                    panel.classList.toggle('active', isActive);
                });

                if (tabName === 'map') {
                    window.loadRegionMap?.();
                }
                if (tabName === 'party') {
                    window.refreshParty?.();
                }
                if (tabName === 'inventory') {
                    window.refreshInventory?.();
                }
            };

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.classList.contains('active')) {
                        return;
                    }
                    activateTab(button.dataset.tab);
                    const newHash = `#${hashPrefix}${button.dataset.tab}`;
                    if (window.location.hash !== newHash) {
                        window.location.hash = newHash;
                    }
                });
            });

            const applyHashTab = () => {
                const rawHash = window.location.hash ? window.location.hash.replace('#', '') : '';
                if (!rawHash) {
                    return;
                }

                if (rawHash.startsWith(hashPrefix)) {
                    const tabName = rawHash.substring(hashPrefix.length);
                    activateTab(tabName);
                } else {
                    activateTab(rawHash);
                }
            };

            applyHashTab();
            window.addEventListener('hashchange', applyHashTab);

            if (!window.location.hash) {
                const defaultButton = document.querySelector('.tab-button.active');
                const defaultTab = defaultButton ? defaultButton.dataset.tab : 'adventure';
                activateTab(defaultTab);
                window.location.hash = `#${hashPrefix}${defaultTab}`;
            }
        }

        function initLocationDisplay() {
            // Function to update location display
            const locationCache = {};
            const locationOverlay = document.getElementById('locationOverlay');
            const locationOverlayText = document.getElementById('locationOverlayText');
            const locationNPCs = document.getElementById('locationNPCs');
            const locationThings = document.getElementById('locationThings');
            let lastRenderedLocation = null;
            const npcDataCache = new Map();
            window.currentNpcData = npcDataCache;
            const npcMenuState = { openMenu: null, trigger: null };

            function closeNpcContextMenu() {
                if (npcMenuState.openMenu) {
                    npcMenuState.openMenu.classList.remove('is-open');
                }
                if (npcMenuState.trigger) {
                    npcMenuState.trigger.setAttribute('aria-expanded', 'false');
                }
                npcMenuState.openMenu = null;
                npcMenuState.trigger = null;
                closeThingContextMenu();
            }

            function registerNpcContextMenu(card, npc) {
                if (!card || !npc || !npc.id) {
                    return;
                }

                card.dataset.npcId = npc.id;

                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'npc-card-menu-button';
                button.setAttribute('aria-haspopup', 'true');
                button.setAttribute('aria-expanded', 'false');
                button.setAttribute('aria-label', `More actions for ${npc.name || 'NPC'}`);

                const icon = document.createElement('span');
                icon.setAttribute('aria-hidden', 'true');
                icon.textContent = '‚Ä¢‚Ä¢‚Ä¢';
                button.appendChild(icon);

                const menu = document.createElement('div');
                menu.className = 'npc-card-menu';

                const viewButton = document.createElement('button');
                viewButton.type = 'button';
                viewButton.className = 'npc-card-menu-item';
                viewButton.textContent = 'View';
                menu.appendChild(viewButton);

                const editButton = document.createElement('button');
                editButton.type = 'button';
                editButton.className = 'npc-card-menu-item';
                editButton.textContent = 'Edit';
                menu.appendChild(editButton);

                const inventoryButton = document.createElement('button');
                inventoryButton.type = 'button';
                inventoryButton.className = 'npc-card-menu-item';
                inventoryButton.textContent = 'Inventory';
                menu.appendChild(inventoryButton);

                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const wasOpen = npcMenuState.openMenu === menu;
                    closeNpcContextMenu();
                    if (!wasOpen) {
                        menu.classList.add('is-open');
                        button.setAttribute('aria-expanded', 'true');
                        npcMenuState.openMenu = menu;
                        npcMenuState.trigger = button;
                    }
                });

                viewButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcViewModal(latestNpc);
                });

                editButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcEditModal(latestNpc);
                });

                inventoryButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    closeNpcContextMenu();
                    const latestNpc = npcDataCache.get(npc.id) || npc;
                    showNpcInventoryModal(latestNpc);
                });

                menu.addEventListener('click', (event) => event.stopPropagation());
                card.addEventListener('click', () => {
                    if (npcMenuState.openMenu) {
                        closeNpcContextMenu();
                    }
                });

                card.appendChild(button);
                card.appendChild(menu);
            }

            window.registerNpcContextMenu = registerNpcContextMenu;

            document.addEventListener('click', () => {
                if (npcMenuState.openMenu) {
                    closeNpcContextMenu();
                }
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeNpcContextMenu();
                }
            });

            function showLocationOverlay(message = 'Loading location...') {
                try {
                    window.floatingTooltipController?.hide?.();
                } catch (_) {
                    // Tooltip controller may not be initialized yet.
                }
                if (locationOverlay) {
                    locationOverlay.classList.add('show');
                    locationOverlay.setAttribute('aria-busy', 'true');
                    if (locationOverlayText && message) {
                        locationOverlayText.textContent = message;
                    }
                }
            }

            function hideLocationOverlay() {
                if (locationOverlay) {
                    locationOverlay.classList.remove('show');
                    locationOverlay.setAttribute('aria-busy', 'false');
                }
            }

            window.updateLocationDisplay = async function(location) {
                const locationName = document.getElementById('locationName');
                const locationTooltip = document.getElementById('locationTooltip');
                const locationHint = document.getElementById('locationHint');
                const locationLevel = document.getElementById('locationLevel');
                const locationImage = document.getElementById('locationImage');
                const locationExits = document.getElementById('locationExits');
                const tooltipController = window.floatingTooltipController;

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                }

                closeNpcContextMenu();
                npcDataCache.clear();

                const maybeLoadThingDetails = async (loc) => {
                    if (!loc) {
                        return [];
                    }
                    let resolvedThings = Array.isArray(loc.things) ? [...loc.things] : [];
                    if (resolvedThings.length === 0 && Array.isArray(loc.thingIds) && loc.thingIds.length > 0) {
                        const fetched = await Promise.all(loc.thingIds.map(fetchThingDetails));
                        resolvedThings = fetched.filter(Boolean);
                        if (resolvedThings.length > 0) {
                            loc.things = resolvedThings;
                        }
                    }
                    return resolvedThings;
                };

                if (location) {
                    const locationDescriptionHtml = location.description || 'No description available.';
                    const locationDescriptionText = locationDescriptionHtml
                        .replace(/<[^>]+>/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim() || 'No description available.';

                    locationName.textContent = location.name || 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = locationDescriptionHtml;
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        const awaitingImage = !location.imageId;
                        locationHint.textContent = awaitingImage
                            ? 'Generating location image...'
                            : (location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.');
                    }
                    locationLevel.textContent = `Level: ${location.baseLevel || '?'}`;
                    locationCache[location.id] = location.name || location.description || location.id;
                    
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        const placeholderMarkup = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';

                        const finalizeTooltip = () => {
                            if (existingTooltip && !existingTooltip.isConnected) {
                                locationImage.appendChild(existingTooltip);
                            }
                        };

                        const renderPromise = renderEntityImage({
                            element: locationImage,
                            entityType: 'location',
                            entityId: location.id,
                            imageId: location.imageId || null,
                            altText: location.name || 'Location image',
                            placeholderIcon: 'üèûÔ∏è',
                            placeholderClass: 'location-placeholder',
                            placeholderMarkup,
                            enableLightbox: true
                        });

                        finalizeTooltip();

                        if (renderPromise && typeof renderPromise.then === 'function') {
                            renderPromise.then(result => {
                                finalizeTooltip();
                                if (result?.imageId && locationHint) {
                                    locationHint.textContent = location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.';
                                }
                            }).catch(() => {
                                finalizeTooltip();
                                if (locationHint) {
                                    locationHint.textContent = 'Image unavailable.';
                                }
                            });
                        }

                        if (locationDescriptionText) {
                            locationImage.setAttribute('aria-label', locationDescriptionText);
                        } else {
                            locationImage.removeAttribute('aria-label');
                        }

                        if (tooltipController && typeof tooltipController.show === 'function') {
                            locationImage.onmouseenter = (event) => {
                                tooltipController.show(locationDescriptionHtml, event, { allowHTML: true });
                            };
                            locationImage.onmousemove = (event) => {
                                tooltipController.move(event);
                            };
                            locationImage.onmouseleave = () => {
                                tooltipController.hide();
                            };
                        } else {
                            locationImage.onmouseenter = null;
                            locationImage.onmousemove = null;
                            locationImage.onmouseleave = null;
                        }
                    }

                    if (locationExits) {
                        const exitEntries = Object.entries(location.exits || {});
                        if (exitEntries.length === 0) {
                            locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                        } else {
                            locationExits.innerHTML = '';
                            exitEntries.forEach(([key, exit]) => {
                                if (!exit || !exit.destination) {
                                    return;
                                }
                                const button = document.createElement('button');
                                button.className = 'exit-button';
                                const targetName = exit.destinationName || locationCache[exit.destination] || exit.description || exit.destination;
                                const isRegionExit = Boolean(exit.destinationRegion);

                                if (isRegionExit) {
                                    button.classList.add('region-exit');
                                    const regionName = exit.destinationRegionName || targetName || 'Unknown region';
                                    const locationName = targetName;
                                    if (exit.destinationRegionExpanded) {
                                        button.textContent = `${regionName}: ${locationName}`;
                                        button.classList.add('region-exit-expanded');
                                    } else {
                                        button.textContent = `Unexplored region: ${regionName}`;
                                        button.classList.add('region-exit-unexplored');
                                    }
                                    if (exit.destinationRegion) {
                                        button.dataset.regionId = exit.destinationRegion;
                                    }
                                } else {
                                    button.textContent = targetName;
                                }

                                button.dataset.destinationId = exit.destination;
                                button.addEventListener('click', () => moveToLocation(exit.destination));
                                locationExits.appendChild(button);
                            });
                        }
                    }

                    if (locationNPCs) {
                        const npcs = Array.isArray(location.npcs) ? location.npcs : [];
                        if (npcs.length === 0) {
                            locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                        } else {
                            locationNPCs.innerHTML = '';
                            npcs.forEach(npc => {
                                const card = document.createElement('div');
                                card.className = 'location-entity-card is-npc';

                                const portrait = document.createElement('div');
                                portrait.className = 'location-entity-icon';

                                renderEntityImage({
                                    element: portrait,
                                    entityType: npc.isNPC ? 'npc' : 'player',
                                    entityId: npc.id,
                                    imageId: npc.imageId || null,
                                    altText: npc.name || 'NPC portrait',
                                    placeholderIcon: 'üé≠',
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = npc.name || 'Unknown NPC';

                                card.appendChild(portrait);
                                card.appendChild(nameEl);
                                const npcDescriptionText = (npc.description || 'No description provided.')
                                    .replace(/<[^>]+>/g, ' ')
                                    .replace(/\s+/g, ' ')
                                    .trim() || 'No description provided.';
                                if (npcDescriptionText) {
                                    card.setAttribute('aria-label', npcDescriptionText);
                                }
                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        tooltipController.show(npcDescriptionText, event);
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                if (npc && npc.id) {
                                    npcDataCache.set(npc.id, npc);
                                    registerNpcContextMenu(card, npc);
                                }
                                locationNPCs.appendChild(card);
                            });
                        }
                    }

                    if (locationThings) {
                        const things = await maybeLoadThingDetails(location);
                        if (things.length === 0) {
                            locationThings.innerHTML = '<div class="location-thing-empty">No notable items or scenery present.</div>';
                        } else {
                            locationThings.innerHTML = '';
                            things.forEach(thing => {
                                const card = document.createElement('div');
                                card.className = `location-entity-card ${thing.thingType === 'scenery' ? 'is-scenery' : 'is-item'}`;

                                const icon = document.createElement('div');
                                icon.className = 'location-entity-icon';
                                const placeholderIcon = thing.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                                renderEntityImage({
                                    element: icon,
                                    entityType: 'thing',
                                    entityId: thing.id,
                                    imageId: thing.imageId || null,
                                    altText: thing.name || 'Location item',
                                    placeholderIcon,
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = thing.name || 'Unknown Object';
                                applyRarityClass(nameEl, thing.rarity);

                                card.appendChild(icon);
                                card.appendChild(nameEl);

                                registerThingContextMenu(card, thing, { context: 'location' });

                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        const tooltipContent = formatThingTooltip(thing);
                                        tooltipController.show(tooltipContent, event, { allowHTML: true });
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                locationThings.appendChild(card);
                            });
                        }
                    }

                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}

                    hideLocationOverlay();
                    lastRenderedLocation = location ? JSON.parse(JSON.stringify(location)) : null;
                } else {
                    locationName.textContent = 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = 'Your current location will appear here when you start exploring.';
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        locationHint.textContent = 'Hover over the location image for a description.';
                    }
                    locationLevel.textContent = 'Level: ?';
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                        locationImage.removeAttribute('aria-label');
                        locationImage.onmouseenter = null;
                        locationImage.onmousemove = null;
                        locationImage.onmouseleave = null;
                    }
                    if (locationNPCs) {
                        locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                    }
                    if (locationThings) {
                        locationThings.innerHTML = '<div class="location-thing-empty">No notable items or scenery present.</div>';
                    }
                    if (locationExits) {
                        locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                    }
                    npcDataCache.clear();
                    closeNpcContextMenu();
                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}
                    hideLocationOverlay();
                    lastRenderedLocation = null;
                }
            };

            document.addEventListener('floatingTooltip:ready', () => {
                if (lastRenderedLocation) {
                    window.updateLocationDisplay(lastRenderedLocation);
                }
            });

            async function moveToLocation(destinationId) {
                if (!destinationId) return;
                try {
                    showLocationOverlay('Exploring new location...');
                    const response = await fetch('/api/player/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destinationId })
                    });

                    const result = await response.json();
                    if (result.success && result.location) {
                        if (result.location.name) {
                            locationCache[result.location.id] = result.location.name;
                        }
                        if (Array.isArray(result.location.exits)) {
                            result.location.exits.forEach(exit => {
                                if (exit.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        } else if (result.location.exits) {
                            Object.values(result.location.exits).forEach(exit => {
                                if (exit?.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        }
                        await window.updateLocationDisplay(result.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    } else if (result.error) {
                        hideLocationOverlay();
                        alert(`Move failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Move failed:', error);
                    hideLocationOverlay();
                    alert(`Move failed: ${error.message}`);
                }
            }

            // Load current player location on page load
            showLocationOverlay('Loading current location...');
            loadCurrentLocation().finally(() => hideLocationOverlay());
        }

        function initInventoryDisplay() {
            const inventoryGrid = document.getElementById('inventoryItems');
            const emptyState = document.getElementById('inventoryEmpty');
            const countLabel = document.getElementById('inventoryCount');
            const floatingTooltip = document.getElementById('inventoryTooltip');
            const inventoryScroll = document.querySelector('.inventory-scroll');
            const equipmentSlotsContainer = document.getElementById('equipmentSlots');
            const equipmentEmpty = document.getElementById('equipmentEmpty');
            const imageMetadataCache = new Map();
            let tooltipController = null;

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            const getItemSlotTags = (item = {}) => {
                const slots = new Set();
                const addSlot = (value) => {
                    if (!value && value !== 0) {
                        return;
                    }
                    if (Array.isArray(value)) {
                        value.forEach(addSlot);
                        return;
                    }
                    const text = String(value).trim();
                    if (text && text.toLowerCase() !== 'n/a') {
                        slots.add(text.toLowerCase());
                    }
                };

                addSlot(item.slot);
                if (item.metadata && Object.prototype.hasOwnProperty.call(item.metadata, 'slot')) {
                    addSlot(item.metadata.slot);
                }

                return Array.from(slots);
            };

            async function updateEquipmentSlot(slotName, itemId, selectElement) {
                if (!slotName) {
                    return;
                }

                const previousValue = selectElement ? (selectElement.dataset.previousValue || '') : '';

                try {
                    if (selectElement) {
                        selectElement.disabled = true;
                    }

                    const response = await fetch('/api/player/equip', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            slotName,
                            itemId: itemId || null
                        })
                    });

                    const data = await response.json();

                    if (!response.ok || !data.success) {
                        const errorMessage = data?.error || `Request failed with status ${response.status}`;
                        throw new Error(errorMessage);
                    }

                    if (selectElement) {
                        const updatedItemId = data.player?.gear?.[slotName]?.itemId || '';
                        selectElement.dataset.previousValue = updatedItemId;
                    }

                    renderInventoryState(data.player || {});
                } catch (error) {
                    console.warn('Failed to update equipment slot:', error);
                    if (selectElement) {
                        selectElement.value = previousValue;
                    }
                    alert(`Failed to update equipment: ${error.message || error}`);
                } finally {
                    if (selectElement) {
                        selectElement.disabled = false;
                    }
                }
            }

            const resetIconToPlaceholder = (iconElement, item, fallbackSymbol = null) => {
                if (!iconElement) return;
                iconElement.classList.remove('has-image');
                iconElement.classList.remove('loading');
                iconElement.style.removeProperty('background-image');
                iconElement.classList.add('inventory-icon-placeholder');
                iconElement.textContent = fallbackSymbol || selectInventoryIcon(item);
                delete iconElement.dataset.lightboxImage;
                delete iconElement.dataset.lightboxAlt;
                delete iconElement.dataset.lightboxCaption;
            };

            const applyImageToIcon = (iconElement, imageUrl, item) => {
                if (!iconElement || !imageUrl) return;
                iconElement.classList.remove('loading');
                iconElement.classList.remove('inventory-icon-placeholder');
                iconElement.classList.add('has-image');
                iconElement.style.backgroundImage = `url('${imageUrl}')`;
                iconElement.textContent = '';

                iconElement.dataset.lightboxImage = imageUrl;
                iconElement.dataset.lightboxAlt = item?.name || 'Inventory item';
                iconElement.dataset.lightboxCaption = item?.name || '';
                bindLightboxElement(iconElement, () => ({
                    src: iconElement.dataset.lightboxImage,
                    alt: iconElement.dataset.lightboxAlt,
                    caption: iconElement.dataset.lightboxCaption
                }));
            };

            function renderEquipment(player = {}, inventoryItems = [], equippedItemIds = new Set()) {
                if (!equipmentSlotsContainer) {
                    return;
                }

                const gear = player && typeof player.gear === 'object' ? player.gear : {};
                const gearEntries = Object.entries(gear);

                equipmentSlotsContainer.innerHTML = '';

                if (!gearEntries.length) {
                    if (equipmentEmpty) {
                        equipmentEmpty.style.display = 'block';
                    }
                    equipmentSlotsContainer.style.display = 'none';
                    return;
                }

                equipmentSlotsContainer.style.display = 'flex';
                if (equipmentEmpty) {
                    equipmentEmpty.style.display = 'none';
                }

                const inventoryById = new Map();
                inventoryItems.forEach(item => {
                    if (item && item.id) {
                        inventoryById.set(item.id, item);
                    }
                });

                gearEntries
                    .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true }))
                    .forEach(([slotName, slotData]) => {
                        const slotType = (slotData?.slotType || '').toString().toLowerCase();
                        const normalizedSlotName = (slotName || '').toLowerCase();

                        addAvailableSlotType(slotType);

                        const wrapper = document.createElement('div');
                        wrapper.className = 'equipment-slot';

                        const selectId = `equipment-select-${slotName.replace(/[^a-zA-Z0-9]+/g, '-').toLowerCase()}`;

                        const label = document.createElement('label');
                        label.className = 'equipment-slot-label';
                        label.setAttribute('for', selectId);
                        label.textContent = slotName || (slotType ? capitalize(slotType) : 'Slot');

                        const select = document.createElement('select');
                        select.className = 'equipment-select';
                        select.id = selectId;
                        select.dataset.slotName = slotName;
                        select.dataset.previousValue = slotData?.itemId || '';

                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'Empty';
                        select.appendChild(emptyOption);

                        const validItems = inventoryItems.filter(item => {
                            const slots = getItemSlotTags(item);
                            if (!slots.length) {
                                return false;
                            }
                            return slots.includes(slotType) || slots.includes(normalizedSlotName);
                        });

                        const optionItems = [];
                        if (slotData?.itemId) {
                            const equippedItem = inventoryById.get(slotData.itemId);
                            if (equippedItem) {
                                optionItems.push(equippedItem);
                            } else {
                                optionItems.push({ id: slotData.itemId, name: `Equipped (${slotData.itemId})` });
                            }
                        }

                        validItems.forEach(item => {
                            if (!optionItems.some(optionItem => optionItem.id === item.id)) {
                                optionItems.push(item);
                            }
                        });

                        optionItems.forEach(item => {
                            if (!item) {
                                return;
                            }
                            const option = document.createElement('option');
                            option.value = item.id || '';
                            option.textContent = item.name || 'Unknown Item';
                            if (slotData?.itemId && item.id === slotData.itemId) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        if (!slotData?.itemId) {
                            select.value = '';
                        }

                        select.addEventListener('change', (event) => {
                            const newValue = event.target.value || '';
                            if (newValue === (slotData?.itemId || '')) {
                                return;
                            }
                            updateEquipmentSlot(slotName, newValue || null, event.target);
                        });

                        wrapper.appendChild(label);
                        wrapper.appendChild(select);
                        equipmentSlotsContainer.appendChild(wrapper);
                    });
            }

            const loadInventoryImage = async (item, iconElement) => {
                if (!iconElement || !item) {
                    return;
                }

                const existingImageId = item.imageId || null;

                if (existingImageId && imageMetadataCache.has(existingImageId)) {
                    applyImageToIcon(iconElement, imageMetadataCache.get(existingImageId), item);
                } else if (existingImageId) {
                    applyImageToIcon(iconElement, `/generated-images/${existingImageId}.png`, item);
                } else {
                    resetIconToPlaceholder(iconElement, item);
                }

                const manager = window.AIRPG?.imageManager;
                if (!manager || !item.id) {
                    return;
                }

                iconElement.classList.add('loading');

                try {
                    const result = await manager.ensureImage({
                        entityType: 'thing',
                        entityId: item.id,
                        existingImageId: existingImageId
                    });

                    const resolvedImageId = result?.imageId || existingImageId;
                    const imageUrl = result?.imageUrl || (resolvedImageId ? `/generated-images/${resolvedImageId}.png` : null);

                    if (resolvedImageId && imageUrl) {
                        imageMetadataCache.set(resolvedImageId, imageUrl);
                        applyImageToIcon(iconElement, imageUrl, item);
                    } else {
                        resetIconToPlaceholder(iconElement, item);
                    }
                } catch (error) {
                    console.warn(`Unable to load inventory image for ${item?.name || item.id}:`, error);
                    resetIconToPlaceholder(iconElement, item);
                } finally {
                    iconElement.classList.remove('loading');
                }
            };

            function renderInventory(items = [], equippedItemIds = new Set()) {
                if (!inventoryGrid || !emptyState || !countLabel) {
                    return;
                }

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                } else {
                    hideTooltip();
                }

                const safeItems = Array.isArray(items) ? items : [];
                safeItems.forEach(trackSlotTypeFromThing);
                const equippedSet = equippedItemIds instanceof Set ? equippedItemIds : new Set();
                inventoryGrid.innerHTML = '';

                countLabel.textContent = `${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`;
                emptyState.style.display = safeItems.length ? 'none' : 'block';
                inventoryGrid.style.display = safeItems.length ? 'flex' : 'none';

                safeItems.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'location-entity-card inventory-card';
                    card.dataset.itemId = item.id || '';

                    const icon = document.createElement('div');
                    icon.className = 'inventory-icon';
                    loadInventoryImage(item, icon);

                    const name = document.createElement('div');
                    name.className = 'inventory-name';
                    name.textContent = item.name || 'Unknown Item';
                    applyRarityClass(name, item.rarity);

                    card.appendChild(icon);
                    card.appendChild(name);
                    if (equippedSet.has(item.id)) {
                        card.classList.add('is-equipped');
                    }
                    registerThingContextMenu(card, item, { context: 'player-inventory' });
                    inventoryGrid.appendChild(card);

                    card.addEventListener('mouseenter', (event) => {
                        if (tooltipController && typeof tooltipController.show === 'function') {
                            const description = item.description || 'No description provided.';
                            const fallbackTooltip = `<div class="tooltip-thing is-item"><div class="tooltip-thing-description">${escapeHtml(description)}</div></div>`;
                            const tooltipContent = formatThingTooltip(item) || fallbackTooltip;
                            tooltipController.show(tooltipContent, event, { allowHTML: true });
                        }
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (tooltipController && typeof tooltipController.move === 'function') {
                            tooltipController.move(event);
                        }
                    });

                    card.addEventListener('mouseleave', () => {
                        if (tooltipController && typeof tooltipController.hide === 'function') {
                            tooltipController.hide();
                        }
                    });
                });

                try { document.dispatchEvent(new Event('inventory:updated')); } catch (_) {}
            }

            function renderInventoryState(player = {}) {
                updateChatPlayerPanel(player);
                if (Array.isArray(player?.partyMembers)) {
                    renderChatPartyPanel(player.partyMembers);
                }

                ensureGearSlotTypes();
                const inventoryItems = Array.isArray(player.inventory) ? player.inventory : [];
                const gear = player && typeof player.gear === 'object' ? player.gear : {};
                const equippedItemIds = new Set();

                updateAvailableSlotTypesFromPlayer(player);

                Object.values(gear).forEach(slot => {
                    if (slot && slot.itemId) {
                        equippedItemIds.add(slot.itemId);
                    }
                });

                renderEquipment(player, inventoryItems, equippedItemIds);
                renderInventory(inventoryItems, equippedItemIds);
            }

            function selectInventoryIcon(item = {}) {
                const type = (item.thingType || item.type || '').toLowerCase();
                if (type.includes('weapon')) return '‚öîÔ∏è';
                if (type.includes('armor')) return 'üõ°Ô∏è';
                if (type.includes('potion')) return 'üß™';
                if (type.includes('tool')) return 'üõ†Ô∏è';
                if (type.includes('trinket')) return 'üßø';
                if (type.includes('container')) return 'üéí';
                return 'üì¶';
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            tooltipController = {
                show(content, event, options = {}) {
                    if (!floatingTooltip || !content || !event) {
                        return;
                    }
                    const { allowHTML = false } = options;
                    if (allowHTML) {
                        floatingTooltip.innerHTML = content;
                    } else {
                        floatingTooltip.textContent = content;
                    }
                    floatingTooltip.removeAttribute('hidden');
                    floatingTooltip.classList.add('visible');
                    positionTooltip(event);
                },
                move(event) {
                    if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) {
                        return;
                    }
                    positionTooltip(event);
                },
                hide() {
                    hideTooltip();
                }
            };

            window.floatingTooltipController = tooltipController;
            try {
                document.dispatchEvent(new CustomEvent('floatingTooltip:ready'));
            } catch (_) {
                // Ignore environments without CustomEvent support.
            }

            window.updateInventoryDisplay = renderInventoryState;

            async function refreshInventory() {
                try {
                    const response = await fetch('/api/player');
                    const data = await response.json();
                    if (data.success && data.player) {
                        renderInventoryState(data.player || {});
                    }
                } catch (error) {
                    console.warn('Failed to refresh inventory:', error);
                }
            }

            window.refreshInventory = refreshInventory;
            refreshInventory();

            if (inventoryScroll) {
                inventoryScroll.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        function initPartyDisplay() {
            const partyGrid = document.getElementById('partyMembers');
            const emptyState = document.getElementById('partyEmpty');
            const countLabel = document.getElementById('partyCount');
            const floatingTooltip = document.getElementById('partyTooltip');
            const partyPanel = document.querySelector('.party-panel');

            const statOrder = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
            const statLabels = {
                strength: 'STR',
                dexterity: 'DEX',
                constitution: 'CON',
                intelligence: 'INT',
                wisdom: 'WIS',
                charisma: 'CHA'
            };

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            const npcDataCache = window.currentNpcData instanceof Map
                ? window.currentNpcData
                : (window.currentNpcData = new Map());

            function renderParty(members = []) {
                if (!partyGrid || !emptyState || !countLabel) {
                    return;
                }

                const safeMembers = Array.isArray(members)
                    ? members.filter(member => member && typeof member === 'object')
                    : [];
                partyGrid.innerHTML = '';
                hideTooltip();

                countLabel.textContent = `${safeMembers.length} ${safeMembers.length === 1 ? 'member' : 'members'}`;
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
                partyGrid.style.display = safeMembers.length ? 'flex' : 'none';

                renderChatPartyPanel(safeMembers);

                safeMembers.forEach(member => {
                    const card = document.createElement('div');
                    card.className = 'party-card';

                    const portrait = document.createElement('div');
                    portrait.className = 'party-portrait';
                    renderEntityImage({
                        element: portrait,
                        entityType: member.isNPC ? 'npc' : 'player',
                        entityId: member.id,
                        imageId: member.imageId || null,
                        altText: member.name || 'Party member portrait',
                        placeholderIcon: 'üé≠',
                        placeholderClass: 'party-portrait-placeholder'
                    });

                    const name = document.createElement('div');
                    name.className = 'party-name';
                    name.textContent = member.name || 'Unknown';

                    const role = document.createElement('div');
                    role.className = 'party-role';
                    const parts = [];
                    if (member.class) parts.push(member.class);
                    if (member.race) parts.push(member.race);
                    role.textContent = parts.join(' ¬∑ ') || 'Companion';

                    const meta = document.createElement('div');
                    meta.className = 'party-meta';
                    const levelText = typeof member.level === 'number' ? `Level ${member.level}` : 'Level ?';
                    meta.textContent = `${levelText}${member.isNPC ? ' ¬∑ NPC' : ''}`;

                    const stats = document.createElement('div');
                    stats.className = 'party-stats';
                    const attrs = member.attributes || {};
                    statOrder.forEach(key => {
                        const value = attrs[key] !== undefined ? attrs[key] : '‚Äî';
                        const stat = document.createElement('div');
                        stat.className = 'party-stat';
                        stat.innerHTML = `<span>${statLabels[key]}</span><strong>${value}</strong>`;
                        stats.appendChild(stat);
                    });

                    const description = member.description || member.shortDescription || 'No description provided.';

                    card.addEventListener('mouseenter', (event) => {
                        if (!floatingTooltip || !description) return;
                        floatingTooltip.textContent = description;
                        floatingTooltip.removeAttribute('hidden');
                        floatingTooltip.classList.add('visible');
                        positionTooltip(event);
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) return;
                        positionTooltip(event);
                    });

                    card.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });

                    card.appendChild(portrait);
                    card.appendChild(name);
                    card.appendChild(role);
                    card.appendChild(meta);
                    card.appendChild(stats);

                    if (member && member.id) {
                        npcDataCache.set(member.id, member);
                    }

                    if (member && member.id && typeof registerNpcContextMenu === 'function') {
                        registerNpcContextMenu(card, member);
                    }

                    partyGrid.appendChild(card);
                });
            }

            window.updatePartyDisplay = renderParty;

            async function refreshParty() {
                try {
                    const response = await fetch('/api/player/party');
                    const data = await response.json();
                    if (data.success && Array.isArray(data.members)) {
                        renderParty(data.members);
                    } else {
                        renderParty([]);
                    }
                } catch (error) {
                    console.warn('Failed to refresh party members:', error);
                    renderParty([]);
                }
            }

            window.refreshParty = refreshParty;
            refreshParty();

            if (partyPanel) {
                partyPanel.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        async function loadCurrentLocation() {
            console.log('Loading current player location...');
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json();
                
                if (result.success && result.player) {
                    updateChatPlayerPanel(result.player);
                    if (Array.isArray(result.player.partyMembers)) {
                        renderChatPartyPanel(result.player.partyMembers);
                    }
                }

                if (result.success && result.player && result.player.currentLocation) {
                    // Fetch location details
                    console.log("Fetching location details for ID:", result.player.currentLocation);
                    const cacheBuster = Date.now();
                    const locationResponse = await fetch(`/api/locations/${result.player.currentLocation}?_=${cacheBuster}`, {
                        cache: 'no-store'
                    });
                    const locationResult = await locationResponse.json();
                    
                    console.log("Current location data:", locationResult.location);

                    if (locationResult.success && locationResult.location) {
                        console.log("Updating location display");
                        await window.updateLocationDisplay(locationResult.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load current location:', error);
                hideLocationOverlay();
            }
        }

        window.loadCurrentLocation = loadCurrentLocation;

        function initSaveLoadButtons() {
            const saveGameBtn = document.getElementById('saveGameBtn');
            const loadGameBtn = document.getElementById('loadGameBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            
            saveGameBtn.addEventListener('click', async function() {
                try {
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Saving...';
                    
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> Saved!';
                        alert(`Game saved successfully!\n\nSave: ${result.saveName}`);
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Save Failed';
                        alert(`Save failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Save Failed';
                    alert(`Save failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üíæ</span> Save Game';
                    }, 2000);
                }
            });

            loadGameBtn.addEventListener('click', async function() {
                try {
                    const response = await fetch('/api/saves');
                    const result = await response.json();
                    
                    if (!result.success || result.saves.length === 0) {
                        alert('No saves found!');
                        return;
                    }
                    
                    // Create a selection dialog
                    let saveOptions = 'Select a save to load:\n\n';
                    result.saves.forEach((save, index) => {
                        const timestamp = new Date(save.timestamp).toLocaleString();
                        saveOptions += `${index + 1}. ${save.playerName} (Level ${save.playerLevel}) - ${timestamp}\n`;
                    });
                    
                    const selection = prompt(saveOptions + '\nEnter the number of the save to load (or 0 to cancel):');
                    const saveIndex = parseInt(selection) - 1;
                    
                    if (saveIndex >= 0 && saveIndex < result.saves.length) {
                        const selectedSave = result.saves[saveIndex];
                        
                        if (confirm(`Load save: ${selectedSave.playerName} (${new Date(selectedSave.timestamp).toLocaleString()})?`)) {
                            this.disabled = true;
                            this.innerHTML = '<span>‚è≥</span> Loading...';
                            
                            const loadResponse = await fetch('/api/load', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ saveName: selectedSave.saveName })
                            });
                            
                            const loadResult = await loadResponse.json();
                            
                            if (loadResult.success) {
                                alert(`Game loaded successfully!\n\n${loadResult.message}`);
                                window.location.reload();
                            } else {
                                alert(`Load failed: ${loadResult.error}`);
                            }
                        }
                    }
                } catch (error) {
                    alert(`Load failed: ${error.message}`);
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<span>üìÇ</span> Load Game';
                }
            });

            if (newGameBtn) {
            newGameBtn.addEventListener('click', async function() {
                try {
                    const confirmation = confirm('Start a new game? This will clear your current progress.\n\nYou can optionally enter a custom player name and description.');
                    if (!confirmation) return;
                    
                    // Get optional player details
                    const playerName = prompt('Enter your character name (or leave blank for "Adventurer"):') || 'Adventurer';
                    const playerDescription = prompt('Enter your character description (optional):') || 'A brave soul embarking on a new adventure.';
                    
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Creating...';
                    
                    const response = await fetch('/api/new-game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playerName: playerName,
                            playerDescription: playerDescription
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> New Game Started!';
                        alert(`New game created successfully!\n\nPlayer: ${result.player.name}\nStarting Location: ${result.startingLocation.name}\n\nYour adventure begins now!`);
                        window.location.reload();
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Failed';
                        alert(`New game creation failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Failed';
                    alert(`New game creation failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üÜï</span> New Game';
                    }, 2000);
                }
            });
            }
        }
    </script>
</body>
</html>
