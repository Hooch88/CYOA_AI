<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title | default("AI RPG Chat") }}</title>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/map.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ AI RPG Chat Interface ü§ñ</h1>
            {% include "_navigation.njk" %}
        </div>
        
        <div class="main-content">
            <div class="tab-bar" role="tablist">
                <button class="tab-button active" id="tab-adventure-tab" data-tab="adventure" role="tab" aria-selected="true" aria-controls="tab-adventure">Adventure</button>
                <button class="tab-button" id="tab-map-tab" data-tab="map" role="tab" aria-selected="false" aria-controls="tab-map">Map</button>
                <button class="tab-button" id="tab-character-tab" data-tab="character" role="tab" aria-selected="false" aria-controls="tab-character">Character</button>
                <button class="tab-button" id="tab-party-tab" data-tab="party" role="tab" aria-selected="false" aria-controls="tab-party">Party</button>
                <button class="tab-button" id="tab-inventory-tab" data-tab="inventory" role="tab" aria-selected="false" aria-controls="tab-inventory">Inventory</button>
            </div>

            <div class="tab-panels">
                <section class="tab-panel active" id="tab-adventure" role="tabpanel" aria-labelledby="tab-adventure-tab">
                    <div class="adventure-content">
                        <div class="location-block">
                            <div class="container">
                                <div class="location-header">
                                    <h4>üìç <span class="location-name" id="locationName">Unknown Location</span></h4>
                                </div>
                                <div class="location-content" id="locationContent">
                                    <div class="location-image" id="locationImage">
                                        <div class="location-placeholder">
                                            <!-- Nothing in here on initial load -->
                                        </div>
                                        <div class="location-tooltip" id="locationTooltip">Your current location will appear here when you start exploring.</div>
                                    </div>
                                    <div class="location-info" id="locationInfo">
                                        <div class="location-details" id="locationDetails">
                                            <span class="location-level" id="locationLevel">Level: ?</span>
                                        </div>
                                        <div class="location-hint" id="locationHint">Hover over the location image for a description.</div>
                                        <details class="location-section location-exits" open>
                                            <summary>Exits</summary>
                                            <div class="location-exits-content" id="locationExits">
                                                <div class="no-exits">No exits discovered yet.</div>
                                            </div>
                                        </details>
                                        <details class="location-section location-npcs" open>
                                            <summary>NPCs</summary>
                                            <div class="location-entity-grid" id="locationNPCs">
                                                <div class="location-npc-empty">No notable NPCs present.</div>
                                            </div>
                                        </details>
                                        <details class="location-section location-things" open>
                                            <summary>Items &amp; Scenery</summary>
                                            <div class="location-entity-grid" id="locationThings">
                                                <div class="location-thing-empty">No notable items or scenery present.</div>
                                            </div>
                                        </details>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="chat-container">
                            <div class="chat-log" id="chatLog">
                                {% if chatHistory and chatHistory.length > 0 %}
                                    {% for message in chatHistory %}
                                        <div class="message {{ 'user-message' if message.role == 'user' else 'ai-message' }}">
                                            <div class="message-sender">
                                                {% if message.role == 'user' %}
                                                    üë§ You
                                                {% else %}
                                                    ü§ñ AI Game Master
                                                {% endif %}
                                            </div>
                                            <div>{{ message.content }}</div>
                                            <div class="message-timestamp">{{ message.timestamp | replace('T', ' ') | replace('Z', '') }}</div>
                                        </div>
                                    {% endfor %}
                                {% else %}
                                    <div class="message ai-message">
                                        <div class="message-sender">ü§ñ AI Game Master</div>
                                        <div>Welcome to the AI RPG! I'm your Game Master. Configure your AI settings above and then describe what kind of adventure you'd like to embark on.</div>
                                    </div>
                                {% endif %}
                            </div>
                            
                            <div class="input-area">
                                <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="2"></textarea>
                                <button class="send-button" id="sendButton">Send</button>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="tab-panel" id="tab-map" role="tabpanel" aria-labelledby="tab-map-tab" hidden>
                    <div id="mapContainer" class="map-placeholder"></div>
                </section>
                <section class="tab-panel" id="tab-character" role="tabpanel" aria-labelledby="tab-character-tab" hidden>
                    <div class="config-content character-panel">
                        <div class="config-section">
                            <h2>Basic Information</h2>
                            <form id="player-stats-form" class="player-stats-form">
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label for="player-name">Character Name</label>
                                        <input type="text"
                                               id="player-name"
                                               name="name"
                                               value="{{ player.name if player else '' }}"
                                               placeholder="Enter character name"
                                               required>
                                        <span class="help-text">Your character's name as it appears in the game</span>
                                    </div>

                                    <div class="form-group">
                                        <label for="player-level">Level</label>
                                        <input type="number"
                                               id="player-level"
                                               name="level"
                                               value="{{ player.level if player else 1 }}"
                                               min="1"
                                               max="20"
                                               required>
                                        <span class="help-text">Character level (1-20)</span>
                                    </div>

                                    <div class="form-group full-width">
                                        <label for="player-description">Description</label>
                                        <textarea id="player-description"
                                                  name="description"
                                                  rows="3"
                                                  placeholder="Describe your character's appearance, personality, and background">{{ player.description if player else '' }}</textarea>
                                        <span class="help-text">A detailed description of your character</span>
                                    </div>
                                </div>
                            </form>
                        </div>

                        <div class="config-section">
                            <h2>Health &amp; Vitality</h2>
                            <div class="form-grid">
                                <div class="form-group">
                                    <label for="player-health">Current Health</label>
                                    <input type="number"
                                           id="player-health"
                                           name="health"
                                           value="{{ player.health if player else 25 }}"
                                           min="0"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Current hit points</span>
                                </div>

                                <div class="form-group">
                                    <label for="player-max-health">Maximum Health</label>
                                    <input type="number"
                                           id="player-max-health"
                                           name="maxHealth"
                                           value="{{ player.maxHealth if player else 25 }}"
                                           min="1"
                                           max="999"
                                           form="player-stats-form">
                                    <span class="help-text">Maximum hit points</span>
                                </div>
                            </div>
                        </div>

                        <div class="config-section">
                            <h2>Primary Attributes</h2>
                            <div class="attributes-grid">
                                {% set attributes = player.attributeInfo if player else {} %}
                                {% set defaultAttributes = [
                                    { key: 'strength', label: 'Strength', abbr: 'STR', description: 'Physical power and muscle' },
                                    { key: 'dexterity', label: 'Dexterity', abbr: 'DEX', description: 'Agility and reflexes' },
                                    { key: 'constitution', label: 'Constitution', abbr: 'CON', description: 'Health and stamina' },
                                    { key: 'intelligence', label: 'Intelligence', abbr: 'INT', description: 'Mental acuity and reasoning' },
                                    { key: 'wisdom', label: 'Wisdom', abbr: 'WIS', description: 'Insight and perception' },
                                    { key: 'charisma', label: 'Charisma', abbr: 'CHA', description: 'Charm and influence' }
                                ] %}

                                {% for attr in defaultAttributes %}
                                <div class="attribute-group">
                                    <div class="attribute-header">
                                        <label for="attr-{{ attr.key }}">{{ attr.label }}</label>
                                        <span class="attribute-abbr">{{ attr.abbr }}</span>
                                    </div>
                                    <div class="attribute-input-group">
                                        <input type="number"
                                               id="attr-{{ attr.key }}"
                                               name="attributes.{{ attr.key }}"
                                               value="{{ attributes[attr.key].value if attributes[attr.key] else 10 }}"
                                               min="3"
                                               max="18"
                                               form="player-stats-form"
                                               class="attribute-input">
                                        <span class="attribute-modifier" data-attr="{{ attr.key }}">
                                            +{{ ((attributes[attr.key].value if attributes[attr.key] else 10) - 10) // 2 }}
                                        </span>
                                    </div>
                                    <span class="help-text">{{ attr.description }}</span>
                                </div>
                                {% endfor %}
                        </div>
                    </div>

                        {% if availableSkills and availableSkills|length %}
                        <div class="config-section">
                            <h2>Skills</h2>
                            <div class="skill-pool-display">
                                <span class="status-label">Unspent Skill Points:</span>
                                <span class="status-value" id="unspentSkillPointsDisplay">{{ player.unspentSkillPoints if player else 0 }}</span>
                            </div>
                            <div class="skills-grid readonly">
                                {% for skill in availableSkills %}
                                {% set skillValue = player.skills[skill.name] if player and player.skills and skill.name in player.skills else 1 %}
                                <div class="skill-card readonly">
                                    <div class="skill-header">
                                        <span class="skill-name">{{ skill.name }}</span>
                                        {% if skill.attribute %}<span class="skill-attribute">{{ skill.attribute }}</span>{% endif %}
                                    </div>
                                    <div class="skill-value">
                                        Rank: <span class="skill-rank" data-skill-name="{{ skill.name }}">{{ skillValue }}</span>
                                        {% if player %}
                                        <button type="button"
                                                class="btn btn-secondary small skill-increase-btn"
                                                data-skill-name="{{ skill.name }}"
                                                aria-label="Increase {{ skill.name }}">
                                            ‚ûï
                                        </button>
                                        {% endif %}
                                    </div>
                                    {% if skill.description %}
                                    <div class="skill-description">{{ skill.description }}</div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}

                        {% if player %}
                        <div class="config-section">
                            <h2>Current Status</h2>
                            <div class="status-display">
                                <div class="status-item">
                                    <span class="status-label">Alive:</span>
                                    <span class="status-value {{ 'alive' if player.alive else 'dead' }}">
                                        {{ 'Yes' if player.alive else 'No' }}
                                    </span>
                                </div>
                                {% if player.currentLocation %}
                                <div class="status-item">
                                    <span class="status-label">Location:</span>
                                    <span class="status-value">{{ player.currentLocation }}</span>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                        {% endif %}

                        <div class="form-actions">
                            <button type="submit" form="player-stats-form" class="btn btn-primary">
                                <span>üíæ</span> Save Character
                            </button>
                            {% if player %}
                            <button type="button" id="reset-stats" class="btn btn-secondary">
                                <span>üîÑ</span> Reset to Defaults
                            </button>
                            {% endif %}
                        </div>

                        <div id="status-message" class="status-message" style="display: none;"></div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-party" role="tabpanel" aria-labelledby="tab-party-tab" hidden>
                    <div class="party-panel">
                        <div class="party-header">
                            <h2>Party Members</h2>
                            <span class="party-count" id="partyCount">0 members</span>
                        </div>
                        <div class="party-grid" id="partyMembers"></div>
                        <div class="party-empty" id="partyEmpty">No companions are currently travelling with you.</div>
                    </div>
                </section>
                <section class="tab-panel" id="tab-inventory" role="tabpanel" aria-labelledby="tab-inventory-tab" hidden>
                    <div class="inventory-layout">
                        <div class="equipment-panel">
                            <div class="equipment-header">
                                <h2>Equipment</h2>
                            </div>
                            <div class="equipment-slots" id="equipmentSlots"></div>
                            <div class="equipment-empty" id="equipmentEmpty">No equipment slots available.</div>
                        </div>
                        <div class="inventory-panel">
                            <div class="inventory-header">
                                <h2>Inventory</h2>
                                <span class="inventory-count" id="inventoryCount">0 items</span>
                            </div>
                            <div class="inventory-scroll">
                                <div class="inventory-grid" id="inventoryItems"></div>
                            </div>
                            <div class="inventory-empty" id="inventoryEmpty">Inventory is empty.</div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <div id="locationOverlay" class="overlay-backdrop" aria-live="polite" aria-busy="false" aria-label="Loading location">
        <div class="overlay-content">
            <div class="spinner" role="status" aria-hidden="true"></div>
            <div class="overlay-text" id="locationOverlayText">Exploring...</div>
        </div>
    </div>

    <div id="inventoryTooltip" class="inventory-floating-tooltip" hidden></div>
    <div id="partyTooltip" class="inventory-floating-tooltip party-floating-tooltip" hidden></div>

    <div id="imageLightbox" class="image-lightbox" hidden aria-hidden="true" tabindex="-1">
        <div class="image-lightbox__inner" role="dialog" aria-modal="true" aria-labelledby="imageLightboxCaption">
            <img id="imageLightboxImage" class="image-lightbox__image" alt="" src="" loading="lazy">
            <div id="imageLightboxCaption" class="image-lightbox__caption" hidden></div>
        </div>
    </div>

    <script src="/vendor/fitty.min.js"></script>
    <script src="/js/fitty-init.js"></script>
    <script src="/vendor/cytoscape.min.js"></script>
    <script src="/vendor/layout-base.js"></script>
    <script src="/vendor/cose-base.js"></script>
    <script src="/vendor/cytoscape-fcose.js"></script>
    <script src="/js/lightbox.js"></script>
    <script src="/js/image-manager.js"></script>
    <script src="/js/chat.js"></script>
    <script defer src="/js/map.js"></script>
    <script defer src="/js/player-stats.js"></script>
    <script>
        // Initialize with system prompt from server
        document.addEventListener('DOMContentLoaded', () => {
            window.systemPrompt = {{ systemPrompt | dump | safe }};
            new AIRPGChat();
            
            // Add save/load functionality
            initSaveLoadButtons();
            
            // Initialize tabs
            initTabs();

            // Initialize location display
            initLocationDisplay();
            initInventoryDisplay();
            initPartyDisplay();
        });

        function bindLightboxElement(element, dataProvider) {
            if (!element || !window.lightboxController) {
                return;
            }

            try {
                window.lightboxController.bind(element, dataProvider);
            } catch (error) {
                console.warn('Failed to bind lightbox:', error);
            }
        }

        const escapeHtml = (value) => {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };

        function renderEntityImage({
            element,
            entityType,
            entityId,
            imageId,
            altText,
            placeholderIcon = 'üñºÔ∏è',
            placeholderClass = 'image-placeholder',
            enableLightbox = true
        }) {
            if (!element) {
                return;
            }

            const safeAltText = escapeHtml(altText || '');
            const placeholderMarkup = `<div class="${placeholderClass}">${placeholderIcon}</div>`;

            const applyImageMarkup = (url) => {
                element.innerHTML = `<img src="${url}" alt="${safeAltText}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'${placeholderClass}\\' role=\\'img\\'>${placeholderIcon}</div>'">`;
                const img = element.querySelector('img');
                if (img && enableLightbox) {
                    img.dataset.lightboxImage = img.src;
                    img.dataset.lightboxAlt = altText || safeAltText || 'Image';
                    img.dataset.lightboxCaption = altText || '';
                    bindLightboxElement(img);
                }
            };

            if (imageId) {
                applyImageMarkup(`/generated-images/${imageId}.png`);
            } else {
                element.innerHTML = placeholderMarkup;
            }

            const manager = window.AIRPG?.imageManager;
            if (!manager || !entityType || !entityId) {
                return;
            }

            manager.ensureImage({
                entityType,
                entityId,
                existingImageId: imageId || null
            }).then(result => {
                if (!result) {
                    return;
                }
                const imageUrl = result.imageUrl || (result.imageId ? `/generated-images/${result.imageId}.png` : null);
                if (imageUrl) {
                    applyImageMarkup(imageUrl);
                }
            }).catch(error => {
                console.warn(`Image generation failed for ${entityType} ${entityId}:`, error?.message || error);
                element.innerHTML = `<div class="${placeholderClass} error">${placeholderIcon}</div>`;
            });
        }

        const capitalize = (value) => {
            if (!value) return '';
            const str = String(value).trim();
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        const normalizeThingType = (thing = {}) => {
            const rawType = (thing.thingType || thing.type || thing.category || '').toLowerCase();
            if (!rawType) {
                return 'item';
            }
            if (rawType.includes('scenery')) {
                return 'scenery';
            }
            if (rawType.includes('item')) {
                return 'item';
            }
            return rawType;
        };

        const formatDetailValue = (value) => {
            if (Array.isArray(value)) {
                return value.map(item => escapeHtml(item)).join(', ');
            }
            if (value && typeof value === 'object') {
                try {
                    return escapeHtml(JSON.stringify(value));
                } catch (_) {
                    return escapeHtml(String(value));
                }
            }
            return escapeHtml(value);
        };

        const rarityClassLookup = [
            { key: 'mythic', className: 'rarity-mythic' },
            { key: 'legendary', className: 'rarity-legendary' },
            { key: 'epic', className: 'rarity-epic' },
            { key: 'very rare', className: 'rarity-rare' },
            { key: 'rare', className: 'rarity-rare' },
            { key: 'uncommon', className: 'rarity-uncommon' },
            { key: 'common', className: 'rarity-common' },
            { key: 'artifact', className: 'rarity-artifact' },
            { key: 'unique', className: 'rarity-unique' },
            { key: 'exotic', className: 'rarity-exotic' },
            { key: 'ancient', className: 'rarity-ancient' },
            { key: 'masterwork', className: 'rarity-masterwork' }
        ];

        const getRarityClass = (rarity) => {
            if (!rarity && rarity !== 0) {
                return '';
            }
            const normalized = String(rarity).trim().toLowerCase();
            if (!normalized) {
                return '';
            }
            for (const entry of rarityClassLookup) {
                if (normalized === entry.key || normalized.includes(entry.key)) {
                    return entry.className;
                }
            }
            return '';
        };

        const applyRarityClass = (element, rarity) => {
            if (!element) {
                return;
            }
            const rarityClass = getRarityClass(rarity);
            if (rarityClass) {
                element.classList.add(rarityClass);
            }
        };

        const formatThingTooltip = (thing = {}) => {
            const normalizedType = normalizeThingType(thing);

            const metaParts = [];
            if (thing.thingType) {
                const label = thing.thingType === 'scenery' ? 'Scenery' : capitalize(thing.thingType);
                metaParts.push(escapeHtml(label));
            } else if (thing.type) {
                metaParts.push(escapeHtml(capitalize(thing.type)));
            } else if (thing.category) {
                metaParts.push(escapeHtml(capitalize(thing.category)));
            } else if (normalizedType) {
                metaParts.push(escapeHtml(capitalize(normalizedType)));
            }
            if (thing.rarity) {
                metaParts.push(escapeHtml(thing.rarity));
            }
            if (thing.itemTypeDetail) {
                metaParts.push(escapeHtml(thing.itemTypeDetail));
            }

            const detailItems = [];
            if (thing.metadata) {
                const { value, weight, properties } = thing.metadata;
                if (value) {
                    detailItems.push({ label: 'Value', value });
                }
                if (weight) {
                    detailItems.push({ label: 'Weight', value: weight });
                }
                if (properties) {
                    detailItems.push({ label: 'Properties', value: properties });
                }
            }
            if (thing.quantity !== undefined && thing.quantity !== null) {
                detailItems.push({ label: 'Quantity', value: thing.quantity });
            }

            const rarityClass = getRarityClass(thing.rarity);
            const nameClasses = ['tooltip-thing-name'];
            if (rarityClass) {
                nameClasses.push(rarityClass);
            }

            const nameHtml = `<div class="${nameClasses.join(' ')}">${escapeHtml(thing.name || 'Unknown Object')}</div>`;
            const metaHtml = metaParts.length
                ? `<div class="tooltip-thing-meta">${metaParts.join(' ‚Ä¢ ')}</div>`
                : '';
            const descriptionHtml = `<div class="tooltip-thing-description">${escapeHtml(thing.description || 'No description provided.').replace(/\n/g, '<br>')}</div>`;
            const detailsHtml = detailItems.length
                ? `<div class="tooltip-thing-details">${detailItems.map(item => `
                        <div class="tooltip-thing-detail">
                            <span class="tooltip-thing-detail-label">${escapeHtml(item.label)}</span>
                            <span class="tooltip-thing-detail-value">${formatDetailValue(item.value)}</span>
                        </div>`).join('')}</div>`
                : '';

            const cardClass = normalizedType === 'scenery' ? 'is-scenery' : 'is-item';

            return `
                <div class="tooltip-thing ${cardClass}">
                    ${nameHtml}
                    ${metaHtml}
                    ${descriptionHtml}
                    ${detailsHtml}
                </div>
            `.trim();
        };

        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanels = document.querySelectorAll('.tab-panel');

            const activateTab = (tabName) => {
                if (!tabName) return;
                const targetButton = Array.from(tabButtons).find(btn => btn.dataset.tab === tabName);
                const targetPanel = document.getElementById(`tab-${tabName}`);
                if (!targetButton || !targetPanel) return;

                tabButtons.forEach(btn => {
                    const isActive = btn === targetButton;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
                });

                tabPanels.forEach(panel => {
                    const isActive = panel === targetPanel;
                    panel.toggleAttribute('hidden', !isActive);
                    panel.classList.toggle('active', isActive);
                });

                if (tabName === 'map') {
                    window.loadRegionMap?.();
                }
                if (tabName === 'party') {
                    window.refreshParty?.();
                }
                if (tabName === 'inventory') {
                    window.refreshInventory?.();
                }
            };

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.classList.contains('active')) {
                        return;
                    }
                    activateTab(button.dataset.tab);
                    if (history.replaceState) {
                        history.replaceState(null, '', `#${button.dataset.tab}`);
                    }
                });
            });

            const applyHashTab = () => {
                const hash = window.location.hash ? window.location.hash.replace('#', '') : '';
                if (hash) {
                    activateTab(hash);
                }
            };

            applyHashTab();
            window.addEventListener('hashchange', applyHashTab);

            if (!window.location.hash) {
                const defaultButton = document.querySelector('.tab-button.active');
                activateTab(defaultButton ? defaultButton.dataset.tab : 'adventure');
            }
        }

        function initLocationDisplay() {
            // Function to update location display
            const locationCache = {};
            const locationOverlay = document.getElementById('locationOverlay');
            const locationOverlayText = document.getElementById('locationOverlayText');
            const locationNPCs = document.getElementById('locationNPCs');
            const locationThings = document.getElementById('locationThings');
            let lastRenderedLocation = null;

            function showLocationOverlay(message = 'Loading location...') {
                try {
                    window.floatingTooltipController?.hide?.();
                } catch (_) {
                    // Tooltip controller may not be initialized yet.
                }
                if (locationOverlay) {
                    locationOverlay.classList.add('show');
                    locationOverlay.setAttribute('aria-busy', 'true');
                    if (locationOverlayText && message) {
                        locationOverlayText.textContent = message;
                    }
                }
            }

            function hideLocationOverlay() {
                if (locationOverlay) {
                    locationOverlay.classList.remove('show');
                    locationOverlay.setAttribute('aria-busy', 'false');
                }
            }

            window.updateLocationDisplay = function(location) {
                const locationName = document.getElementById('locationName');
                const locationTooltip = document.getElementById('locationTooltip');
                const locationHint = document.getElementById('locationHint');
                const locationLevel = document.getElementById('locationLevel');
                const locationImage = document.getElementById('locationImage');
                const locationExits = document.getElementById('locationExits');
                const tooltipController = window.floatingTooltipController;

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                }
                
                if (location) {
                    const locationDescriptionHtml = location.description || 'No description available.';
                    const locationDescriptionText = locationDescriptionHtml
                        .replace(/<[^>]+>/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim() || 'No description available.';

                    locationName.textContent = location.name || 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = locationDescriptionHtml;
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        const awaitingImage = !location.imageId;
                        locationHint.textContent = awaitingImage
                            ? 'Generating location image...'
                            : (location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.');
                    }
                    locationLevel.textContent = `Level: ${location.baseLevel || '?'}`;
                    locationCache[location.id] = location.name || location.description || location.id;
                    
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        const applyLocationImage = (imageUrl) => {
                            if (!imageUrl) {
                                locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                                return;
                            }

                            const safeAlt = (location.name || 'Location image').replace(/"/g, '&quot;');
                            locationImage.innerHTML = `<img src="${imageUrl}" alt="${safeAlt}" onerror="this.parentElement.innerHTML='<div class=\\'location-placeholder\\'>üèûÔ∏è<p>Image not found</p></div>'">`;
                            const previewImage = locationImage.querySelector('img');
                            if (previewImage) {
                                previewImage.dataset.lightboxImage = previewImage.src;
                                previewImage.dataset.lightboxAlt = location.name || 'Location image';
                                previewImage.dataset.lightboxCaption = location.name || '';
                                bindLightboxElement(previewImage);
                            }
                        };

                        if (location.imageId && !location.pendingImageJobId) {
                            applyLocationImage(`/generated-images/${location.imageId}.png`);
                        } else {
                            locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                        }

                        if (window.AIRPG?.imageManager && location.id) {
                            window.AIRPG.imageManager.ensureImage({
                                entityType: 'location',
                                entityId: location.id,
                                existingImageId: location.imageId || null
                            }).then(result => {
                                if (!result) {
                                    return;
                                }
                                const imageUrl = result.imageUrl
                                    || (result.imageId ? `/generated-images/${result.imageId}.png` : null);
                                if (imageUrl) {
                                    applyLocationImage(imageUrl);
                                    if (locationHint) {
                                        locationHint.textContent = location.description ? 'Hover over the location image for a description.' : 'No description available for this location yet.';
                                    }
                                }
                            }).catch(error => {
                                console.warn('Location image generation failed:', error?.message || error);
                                locationImage.innerHTML = '<div class="location-placeholder error"><span>‚ö†Ô∏è</span><p>Image unavailable</p></div>';
                            });
                        }

                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }

                        if (locationDescriptionText) {
                            locationImage.setAttribute('aria-label', locationDescriptionText);
                        } else {
                            locationImage.removeAttribute('aria-label');
                        }

                        if (tooltipController && typeof tooltipController.show === 'function') {
                            locationImage.onmouseenter = (event) => {
                                tooltipController.show(locationDescriptionHtml, event, { allowHTML: true });
                            };
                            locationImage.onmousemove = (event) => {
                                tooltipController.move(event);
                            };
                            locationImage.onmouseleave = () => {
                                tooltipController.hide();
                            };
                        } else {
                            locationImage.onmouseenter = null;
                            locationImage.onmousemove = null;
                            locationImage.onmouseleave = null;
                        }
                    }

                    if (locationExits) {
                        const exitEntries = Object.entries(location.exits || {});
                        if (exitEntries.length === 0) {
                            locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                        } else {
                            locationExits.innerHTML = '';
                            exitEntries.forEach(([key, exit]) => {
                                if (!exit || !exit.destination) {
                                    return;
                                }
                                const button = document.createElement('button');
                                button.className = 'exit-button';
                                const targetName = exit.destinationName || locationCache[exit.destination] || exit.description || exit.destination;
                                button.textContent = targetName;
                                button.dataset.destinationId = exit.destination;
                                button.addEventListener('click', () => moveToLocation(exit.destination));
                                locationExits.appendChild(button);
                            });
                        }
                    }

                    if (locationNPCs) {
                        const npcs = Array.isArray(location.npcs) ? location.npcs : [];
                        if (npcs.length === 0) {
                            locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                        } else {
                            locationNPCs.innerHTML = '';
                            npcs.forEach(npc => {
                                const card = document.createElement('div');
                                card.className = 'location-entity-card is-npc';

                                const portrait = document.createElement('div');
                                portrait.className = 'location-entity-icon';

                                renderEntityImage({
                                    element: portrait,
                                    entityType: npc.isNPC ? 'npc' : 'player',
                                    entityId: npc.id,
                                    imageId: npc.imageId || null,
                                    altText: npc.name || 'NPC portrait',
                                    placeholderIcon: 'üé≠',
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = npc.name || 'Unknown NPC';

                                card.appendChild(portrait);
                                card.appendChild(nameEl);
                                const npcDescriptionText = (npc.description || 'No description provided.')
                                    .replace(/<[^>]+>/g, ' ')
                                    .replace(/\s+/g, ' ')
                                    .trim() || 'No description provided.';
                                if (npcDescriptionText) {
                                    card.setAttribute('aria-label', npcDescriptionText);
                                }
                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        tooltipController.show(npcDescriptionText, event);
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }
                                locationNPCs.appendChild(card);
                            });
                        }
                    }

                    if (locationThings) {
                        const things = Array.isArray(location.things) ? location.things : [];
                        if (things.length === 0) {
                            locationThings.innerHTML = '<div class="location-thing-empty">No notable items or scenery present.</div>';
                        } else {
                            locationThings.innerHTML = '';
                            things.forEach(thing => {
                                const card = document.createElement('div');
                                card.className = `location-entity-card ${thing.thingType === 'scenery' ? 'is-scenery' : 'is-item'}`;

                                const icon = document.createElement('div');
                                icon.className = 'location-entity-icon';
                                const placeholderIcon = thing.thingType === 'scenery' ? 'üèûÔ∏è' : 'üéÅ';
                                renderEntityImage({
                                    element: icon,
                                    entityType: 'thing',
                                    entityId: thing.id,
                                    imageId: thing.imageId || null,
                                    altText: thing.name || 'Location item',
                                    placeholderIcon,
                                    placeholderClass: 'location-entity-placeholder'
                                });

                                const nameEl = document.createElement('div');
                                nameEl.className = 'location-entity-name';
                                nameEl.textContent = thing.name || 'Unknown Object';
                                applyRarityClass(nameEl, thing.rarity);

                                card.appendChild(icon);
                                card.appendChild(nameEl);

                                if (tooltipController && typeof tooltipController.show === 'function') {
                                    card.addEventListener('mouseenter', (event) => {
                                        const tooltipContent = formatThingTooltip(thing);
                                        tooltipController.show(tooltipContent, event, { allowHTML: true });
                                    });
                                    card.addEventListener('mousemove', (event) => {
                                        tooltipController.move(event);
                                    });
                                    card.addEventListener('mouseleave', () => {
                                        tooltipController.hide();
                                    });
                                }

                                locationThings.appendChild(card);
                            });
                        }
                    }

                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}

                    hideLocationOverlay();
                    lastRenderedLocation = location ? JSON.parse(JSON.stringify(location)) : null;
                } else {
                    locationName.textContent = 'Unknown Location';
                    if (locationTooltip) {
                        locationTooltip.innerHTML = 'Your current location will appear here when you start exploring.';
                        locationTooltip.setAttribute('hidden', '');
                        locationTooltip.setAttribute('aria-hidden', 'true');
                    }
                    if (locationHint) {
                        locationHint.textContent = 'Hover over the location image for a description.';
                    }
                    locationLevel.textContent = 'Level: ?';
                    if (locationImage) {
                        const existingTooltip = locationImage.querySelector('.location-tooltip');
                        locationImage.innerHTML = '<div class="location-placeholder"><div class="spinner" role="status" aria-hidden="true"></div></div>';
                        if (existingTooltip) {
                            locationImage.appendChild(existingTooltip);
                        }
                        locationImage.removeAttribute('aria-label');
                        locationImage.onmouseenter = null;
                        locationImage.onmousemove = null;
                        locationImage.onmouseleave = null;
                    }
                    if (locationNPCs) {
                        locationNPCs.innerHTML = '<div class="location-npc-empty">No notable NPCs present.</div>';
                    }
                    if (locationThings) {
                        locationThings.innerHTML = '<div class="location-thing-empty">No notable items or scenery present.</div>';
                    }
                    if (locationExits) {
                        locationExits.innerHTML = '<div class="no-exits">No exits discovered yet.</div>';
                    }
                    try { document.dispatchEvent(new Event('location:updated')); } catch (_) {}
                    hideLocationOverlay();
                    lastRenderedLocation = null;
                }
            };

            document.addEventListener('floatingTooltip:ready', () => {
                if (lastRenderedLocation) {
                    window.updateLocationDisplay(lastRenderedLocation);
                }
            });

            async function moveToLocation(destinationId) {
                if (!destinationId) return;
                try {
                    showLocationOverlay('Exploring new location...');
                    const response = await fetch('/api/player/move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destinationId })
                    });

                    const result = await response.json();
                    if (result.success && result.location) {
                        if (result.location.name) {
                            locationCache[result.location.id] = result.location.name;
                        }
                        if (Array.isArray(result.location.exits)) {
                            result.location.exits.forEach(exit => {
                                if (exit.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        } else if (result.location.exits) {
                            Object.values(result.location.exits).forEach(exit => {
                                if (exit?.destination && exit.destinationName) {
                                    locationCache[exit.destination] = exit.destinationName;
                                }
                            });
                        }
                        window.updateLocationDisplay(result.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    } else if (result.error) {
                        hideLocationOverlay();
                        alert(`Move failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Move failed:', error);
                    hideLocationOverlay();
                    alert(`Move failed: ${error.message}`);
                }
            }

            // Load current player location on page load
            showLocationOverlay('Loading current location...');
            loadCurrentLocation().finally(() => hideLocationOverlay());
        }

        function initInventoryDisplay() {
            const inventoryGrid = document.getElementById('inventoryItems');
            const emptyState = document.getElementById('inventoryEmpty');
            const countLabel = document.getElementById('inventoryCount');
            const floatingTooltip = document.getElementById('inventoryTooltip');
            const inventoryScroll = document.querySelector('.inventory-scroll');
            const equipmentSlotsContainer = document.getElementById('equipmentSlots');
            const equipmentEmpty = document.getElementById('equipmentEmpty');
            const imageMetadataCache = new Map();
            let tooltipController = null;

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            const getItemSlotTags = (item = {}) => {
                const slots = new Set();
                const addSlot = (value) => {
                    if (!value && value !== 0) {
                        return;
                    }
                    if (Array.isArray(value)) {
                        value.forEach(addSlot);
                        return;
                    }
                    const text = String(value).trim();
                    if (text && text.toLowerCase() !== 'n/a') {
                        slots.add(text.toLowerCase());
                    }
                };

                addSlot(item.slot);
                if (item.metadata && Object.prototype.hasOwnProperty.call(item.metadata, 'slot')) {
                    addSlot(item.metadata.slot);
                }

                return Array.from(slots);
            };

            async function updateEquipmentSlot(slotName, itemId, selectElement) {
                if (!slotName) {
                    return;
                }

                const previousValue = selectElement ? (selectElement.dataset.previousValue || '') : '';

                try {
                    if (selectElement) {
                        selectElement.disabled = true;
                    }

                    const response = await fetch('/api/player/equip', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            slotName,
                            itemId: itemId || null
                        })
                    });

                    const data = await response.json();

                    if (!response.ok || !data.success) {
                        const errorMessage = data?.error || `Request failed with status ${response.status}`;
                        throw new Error(errorMessage);
                    }

                    if (selectElement) {
                        const updatedItemId = data.player?.gear?.[slotName]?.itemId || '';
                        selectElement.dataset.previousValue = updatedItemId;
                    }

                    renderInventoryState(data.player || {});
                } catch (error) {
                    console.warn('Failed to update equipment slot:', error);
                    if (selectElement) {
                        selectElement.value = previousValue;
                    }
                    alert(`Failed to update equipment: ${error.message || error}`);
                } finally {
                    if (selectElement) {
                        selectElement.disabled = false;
                    }
                }
            }

            const resetIconToPlaceholder = (iconElement, item, fallbackSymbol = null) => {
                if (!iconElement) return;
                iconElement.classList.remove('has-image');
                iconElement.classList.remove('loading');
                iconElement.style.removeProperty('background-image');
                iconElement.classList.add('inventory-icon-placeholder');
                iconElement.textContent = fallbackSymbol || selectInventoryIcon(item);
                delete iconElement.dataset.lightboxImage;
                delete iconElement.dataset.lightboxAlt;
                delete iconElement.dataset.lightboxCaption;
            };

            const applyImageToIcon = (iconElement, imageUrl, item) => {
                if (!iconElement || !imageUrl) return;
                iconElement.classList.remove('loading');
                iconElement.classList.remove('inventory-icon-placeholder');
                iconElement.classList.add('has-image');
                iconElement.style.backgroundImage = `url('${imageUrl}')`;
                iconElement.textContent = '';

                iconElement.dataset.lightboxImage = imageUrl;
                iconElement.dataset.lightboxAlt = item?.name || 'Inventory item';
                iconElement.dataset.lightboxCaption = item?.name || '';
                bindLightboxElement(iconElement, () => ({
                    src: iconElement.dataset.lightboxImage,
                    alt: iconElement.dataset.lightboxAlt,
                    caption: iconElement.dataset.lightboxCaption
                }));
            };

            function renderEquipment(player = {}, inventoryItems = [], equippedItemIds = new Set()) {
                if (!equipmentSlotsContainer) {
                    return;
                }

                const gear = player && typeof player.gear === 'object' ? player.gear : {};
                const gearEntries = Object.entries(gear);

                equipmentSlotsContainer.innerHTML = '';

                if (!gearEntries.length) {
                    if (equipmentEmpty) {
                        equipmentEmpty.style.display = 'block';
                    }
                    equipmentSlotsContainer.style.display = 'none';
                    return;
                }

                equipmentSlotsContainer.style.display = 'flex';
                if (equipmentEmpty) {
                    equipmentEmpty.style.display = 'none';
                }

                const inventoryById = new Map();
                inventoryItems.forEach(item => {
                    if (item && item.id) {
                        inventoryById.set(item.id, item);
                    }
                });

                gearEntries
                    .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true }))
                    .forEach(([slotName, slotData]) => {
                        const slotType = (slotData?.slotType || '').toString().toLowerCase();
                        const normalizedSlotName = (slotName || '').toLowerCase();

                        const wrapper = document.createElement('div');
                        wrapper.className = 'equipment-slot';

                        const selectId = `equipment-select-${slotName.replace(/[^a-zA-Z0-9]+/g, '-').toLowerCase()}`;

                        const label = document.createElement('label');
                        label.className = 'equipment-slot-label';
                        label.setAttribute('for', selectId);
                        label.textContent = slotName || (slotType ? capitalize(slotType) : 'Slot');

                        const select = document.createElement('select');
                        select.className = 'equipment-select';
                        select.id = selectId;
                        select.dataset.slotName = slotName;
                        select.dataset.previousValue = slotData?.itemId || '';

                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = 'Empty';
                        select.appendChild(emptyOption);

                        const validItems = inventoryItems.filter(item => {
                            const slots = getItemSlotTags(item);
                            if (!slots.length) {
                                return false;
                            }
                            return slots.includes(slotType) || slots.includes(normalizedSlotName);
                        });

                        const optionItems = [];
                        if (slotData?.itemId) {
                            const equippedItem = inventoryById.get(slotData.itemId);
                            if (equippedItem) {
                                optionItems.push(equippedItem);
                            } else {
                                optionItems.push({ id: slotData.itemId, name: `Equipped (${slotData.itemId})` });
                            }
                        }

                        validItems.forEach(item => {
                            if (!optionItems.some(optionItem => optionItem.id === item.id)) {
                                optionItems.push(item);
                            }
                        });

                        optionItems.forEach(item => {
                            if (!item) {
                                return;
                            }
                            const option = document.createElement('option');
                            option.value = item.id || '';
                            option.textContent = item.name || 'Unknown Item';
                            if (slotData?.itemId && item.id === slotData.itemId) {
                                option.selected = true;
                            }
                            select.appendChild(option);
                        });

                        if (!slotData?.itemId) {
                            select.value = '';
                        }

                        select.addEventListener('change', (event) => {
                            const newValue = event.target.value || '';
                            if (newValue === (slotData?.itemId || '')) {
                                return;
                            }
                            updateEquipmentSlot(slotName, newValue || null, event.target);
                        });

                        wrapper.appendChild(label);
                        wrapper.appendChild(select);
                        equipmentSlotsContainer.appendChild(wrapper);
                    });
            }

            const loadInventoryImage = async (item, iconElement) => {
                if (!iconElement || !item) {
                    return;
                }

                const existingImageId = item.imageId || null;

                if (existingImageId && imageMetadataCache.has(existingImageId)) {
                    applyImageToIcon(iconElement, imageMetadataCache.get(existingImageId), item);
                } else if (existingImageId) {
                    applyImageToIcon(iconElement, `/generated-images/${existingImageId}.png`, item);
                } else {
                    resetIconToPlaceholder(iconElement, item);
                }

                const manager = window.AIRPG?.imageManager;
                if (!manager || !item.id) {
                    return;
                }

                iconElement.classList.add('loading');

                try {
                    const result = await manager.ensureImage({
                        entityType: 'thing',
                        entityId: item.id,
                        existingImageId: existingImageId
                    });

                    const resolvedImageId = result?.imageId || existingImageId;
                    const imageUrl = result?.imageUrl || (resolvedImageId ? `/generated-images/${resolvedImageId}.png` : null);

                    if (resolvedImageId && imageUrl) {
                        imageMetadataCache.set(resolvedImageId, imageUrl);
                        applyImageToIcon(iconElement, imageUrl, item);
                    } else {
                        resetIconToPlaceholder(iconElement, item);
                    }
                } catch (error) {
                    console.warn(`Unable to load inventory image for ${item?.name || item.id}:`, error);
                    resetIconToPlaceholder(iconElement, item);
                } finally {
                    iconElement.classList.remove('loading');
                }
            };

            function renderInventory(items = [], equippedItemIds = new Set()) {
                if (!inventoryGrid || !emptyState || !countLabel) {
                    return;
                }

                if (tooltipController && typeof tooltipController.hide === 'function') {
                    tooltipController.hide();
                } else {
                    hideTooltip();
                }

                const safeItems = Array.isArray(items) ? items : [];
                const equippedSet = equippedItemIds instanceof Set ? equippedItemIds : new Set();
                inventoryGrid.innerHTML = '';

                countLabel.textContent = `${safeItems.length} ${safeItems.length === 1 ? 'item' : 'items'}`;
                emptyState.style.display = safeItems.length ? 'none' : 'block';
                inventoryGrid.style.display = safeItems.length ? 'flex' : 'none';

                safeItems.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'location-entity-card inventory-card';
                    card.dataset.itemId = item.id || '';

                    const icon = document.createElement('div');
                    icon.className = 'inventory-icon';
                    loadInventoryImage(item, icon);

                    const name = document.createElement('div');
                    name.className = 'inventory-name';
                    name.textContent = item.name || 'Unknown Item';
                    applyRarityClass(name, item.rarity);

                    card.appendChild(icon);
                    card.appendChild(name);
                    if (equippedSet.has(item.id)) {
                        card.classList.add('is-equipped');
                    }
                    inventoryGrid.appendChild(card);

                    card.addEventListener('mouseenter', (event) => {
                        if (tooltipController && typeof tooltipController.show === 'function') {
                            const description = item.description || 'No description provided.';
                            const fallbackTooltip = `<div class="tooltip-thing is-item"><div class="tooltip-thing-description">${escapeHtml(description)}</div></div>`;
                            const tooltipContent = formatThingTooltip(item) || fallbackTooltip;
                            tooltipController.show(tooltipContent, event, { allowHTML: true });
                        }
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (tooltipController && typeof tooltipController.move === 'function') {
                            tooltipController.move(event);
                        }
                    });

                    card.addEventListener('mouseleave', () => {
                        if (tooltipController && typeof tooltipController.hide === 'function') {
                            tooltipController.hide();
                        }
                    });
                });

                try { document.dispatchEvent(new Event('inventory:updated')); } catch (_) {}
            }

            function renderInventoryState(player = {}) {
                const inventoryItems = Array.isArray(player.inventory) ? player.inventory : [];
                const gear = player && typeof player.gear === 'object' ? player.gear : {};
                const equippedItemIds = new Set();

                Object.values(gear).forEach(slot => {
                    if (slot && slot.itemId) {
                        equippedItemIds.add(slot.itemId);
                    }
                });

                renderEquipment(player, inventoryItems, equippedItemIds);
                renderInventory(inventoryItems, equippedItemIds);
            }

            function selectInventoryIcon(item = {}) {
                const type = (item.thingType || item.type || '').toLowerCase();
                if (type.includes('weapon')) return '‚öîÔ∏è';
                if (type.includes('armor')) return 'üõ°Ô∏è';
                if (type.includes('potion')) return 'üß™';
                if (type.includes('tool')) return 'üõ†Ô∏è';
                if (type.includes('trinket')) return 'üßø';
                if (type.includes('container')) return 'üéí';
                return 'üì¶';
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            tooltipController = {
                show(content, event, options = {}) {
                    if (!floatingTooltip || !content || !event) {
                        return;
                    }
                    const { allowHTML = false } = options;
                    if (allowHTML) {
                        floatingTooltip.innerHTML = content;
                    } else {
                        floatingTooltip.textContent = content;
                    }
                    floatingTooltip.removeAttribute('hidden');
                    floatingTooltip.classList.add('visible');
                    positionTooltip(event);
                },
                move(event) {
                    if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) {
                        return;
                    }
                    positionTooltip(event);
                },
                hide() {
                    hideTooltip();
                }
            };

            window.floatingTooltipController = tooltipController;
            try {
                document.dispatchEvent(new CustomEvent('floatingTooltip:ready'));
            } catch (_) {
                // Ignore environments without CustomEvent support.
            }

            window.updateInventoryDisplay = renderInventoryState;

            async function refreshInventory() {
                try {
                    const response = await fetch('/api/player');
                    const data = await response.json();
                    if (data.success && data.player) {
                        renderInventoryState(data.player || {});
                    }
                } catch (error) {
                    console.warn('Failed to refresh inventory:', error);
                }
            }

            window.refreshInventory = refreshInventory;
            refreshInventory();

            if (inventoryScroll) {
                inventoryScroll.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        function initPartyDisplay() {
            const partyGrid = document.getElementById('partyMembers');
            const emptyState = document.getElementById('partyEmpty');
            const countLabel = document.getElementById('partyCount');
            const floatingTooltip = document.getElementById('partyTooltip');
            const partyPanel = document.querySelector('.party-panel');

            const statOrder = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
            const statLabels = {
                strength: 'STR',
                dexterity: 'DEX',
                constitution: 'CON',
                intelligence: 'INT',
                wisdom: 'WIS',
                charisma: 'CHA'
            };

            function hideTooltip() {
                if (!floatingTooltip) return;
                floatingTooltip.classList.remove('visible');
                floatingTooltip.setAttribute('hidden', '');
            }

            function positionTooltip(event) {
                if (!floatingTooltip) return;
                const padding = 16;
                const tooltipRect = floatingTooltip.getBoundingClientRect();
                let x = event.clientX + padding;
                let y = event.clientY + padding;

                if (x + tooltipRect.width + padding > window.innerWidth) {
                    x = Math.max(padding, window.innerWidth - tooltipRect.width - padding);
                }

                if (y + tooltipRect.height + padding > window.innerHeight) {
                    y = event.clientY - tooltipRect.height - padding;
                    if (y < padding) {
                        y = Math.max(padding, window.innerHeight - tooltipRect.height - padding);
                    }
                }

                floatingTooltip.style.left = `${x}px`;
                floatingTooltip.style.top = `${y}px`;
            }

            function renderParty(members = []) {
                if (!partyGrid || !emptyState || !countLabel) {
                    return;
                }

                const safeMembers = Array.isArray(members) ? members : [];
                partyGrid.innerHTML = '';
                hideTooltip();

                countLabel.textContent = `${safeMembers.length} ${safeMembers.length === 1 ? 'member' : 'members'}`;
                emptyState.style.display = safeMembers.length ? 'none' : 'block';
                partyGrid.style.display = safeMembers.length ? 'flex' : 'none';

                safeMembers.forEach(member => {
                    const card = document.createElement('div');
                    card.className = 'party-card';

                    const portrait = document.createElement('div');
                    portrait.className = 'party-portrait';
                    renderEntityImage({
                        element: portrait,
                        entityType: member.isNPC ? 'npc' : 'player',
                        entityId: member.id,
                        imageId: member.imageId || null,
                        altText: member.name || 'Party member portrait',
                        placeholderIcon: 'üé≠',
                        placeholderClass: 'party-portrait-placeholder'
                    });

                    const name = document.createElement('div');
                    name.className = 'party-name';
                    name.textContent = member.name || 'Unknown';

                    const role = document.createElement('div');
                    role.className = 'party-role';
                    const parts = [];
                    if (member.class) parts.push(member.class);
                    if (member.race) parts.push(member.race);
                    role.textContent = parts.join(' ¬∑ ') || 'Companion';

                    const meta = document.createElement('div');
                    meta.className = 'party-meta';
                    const levelText = typeof member.level === 'number' ? `Level ${member.level}` : 'Level ?';
                    meta.textContent = `${levelText}${member.isNPC ? ' ¬∑ NPC' : ''}`;

                    const stats = document.createElement('div');
                    stats.className = 'party-stats';
                    const attrs = member.attributes || {};
                    statOrder.forEach(key => {
                        const value = attrs[key] !== undefined ? attrs[key] : '‚Äî';
                        const stat = document.createElement('div');
                        stat.className = 'party-stat';
                        stat.innerHTML = `<span>${statLabels[key]}</span><strong>${value}</strong>`;
                        stats.appendChild(stat);
                    });

                    const description = member.description || member.shortDescription || 'No description provided.';

                    card.addEventListener('mouseenter', (event) => {
                        if (!floatingTooltip || !description) return;
                        floatingTooltip.textContent = description;
                        floatingTooltip.removeAttribute('hidden');
                        floatingTooltip.classList.add('visible');
                        positionTooltip(event);
                    });

                    card.addEventListener('mousemove', (event) => {
                        if (!floatingTooltip || floatingTooltip.hasAttribute('hidden')) return;
                        positionTooltip(event);
                    });

                    card.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });

                    card.appendChild(portrait);
                    card.appendChild(name);
                    card.appendChild(role);
                    card.appendChild(meta);
                    card.appendChild(stats);
                    partyGrid.appendChild(card);
                });
            }

            window.updatePartyDisplay = renderParty;

            async function refreshParty() {
                try {
                    const response = await fetch('/api/player/party');
                    const data = await response.json();
                    if (data.success && Array.isArray(data.members)) {
                        renderParty(data.members);
                    } else {
                        renderParty([]);
                    }
                } catch (error) {
                    console.warn('Failed to refresh party members:', error);
                    renderParty([]);
                }
            }

            window.refreshParty = refreshParty;
            refreshParty();

            if (partyPanel) {
                partyPanel.addEventListener('scroll', hideTooltip);
            }
            window.addEventListener('scroll', hideTooltip, { passive: true });
        }

        async function loadCurrentLocation() {
            console.log('Loading current player location...');
            try {
                const response = await fetch('/api/player', { cache: 'no-store' });
                const result = await response.json();
                
                if (result.success && result.player && result.player.currentLocation) {
                    // Fetch location details
                    console.log("Fetching location details for ID:", result.player.currentLocation);
                    const cacheBuster = Date.now();
                    const locationResponse = await fetch(`/api/locations/${result.player.currentLocation}?_=${cacheBuster}`, {
                        cache: 'no-store'
                    });
                    const locationResult = await locationResponse.json();
                    
                    console.log("Current location data:", locationResult.location);

                    if (locationResult.success && locationResult.location) {
                        console.log("Updating location display");
                        window.updateLocationDisplay(locationResult.location);
                        if (document.querySelector('[data-tab="map"]').classList.contains('active')) {
                            window.loadRegionMap?.();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load current location:', error);
                hideLocationOverlay();
            }
        }

        function initSaveLoadButtons() {
            const saveGameBtn = document.getElementById('saveGameBtn');
            const loadGameBtn = document.getElementById('loadGameBtn');
            const newGameBtn = document.getElementById('newGameBtn');
            
            saveGameBtn.addEventListener('click', async function() {
                try {
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Saving...';
                    
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> Saved!';
                        alert(`Game saved successfully!\n\nSave: ${result.saveName}`);
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Save Failed';
                        alert(`Save failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Save Failed';
                    alert(`Save failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üíæ</span> Save Game';
                    }, 2000);
                }
            });

            loadGameBtn.addEventListener('click', async function() {
                try {
                    const response = await fetch('/api/saves');
                    const result = await response.json();
                    
                    if (!result.success || result.saves.length === 0) {
                        alert('No saves found!');
                        return;
                    }
                    
                    // Create a selection dialog
                    let saveOptions = 'Select a save to load:\n\n';
                    result.saves.forEach((save, index) => {
                        const timestamp = new Date(save.timestamp).toLocaleString();
                        saveOptions += `${index + 1}. ${save.playerName} (Level ${save.playerLevel}) - ${timestamp}\n`;
                    });
                    
                    const selection = prompt(saveOptions + '\nEnter the number of the save to load (or 0 to cancel):');
                    const saveIndex = parseInt(selection) - 1;
                    
                    if (saveIndex >= 0 && saveIndex < result.saves.length) {
                        const selectedSave = result.saves[saveIndex];
                        
                        if (confirm(`Load save: ${selectedSave.playerName} (${new Date(selectedSave.timestamp).toLocaleString()})?`)) {
                            this.disabled = true;
                            this.innerHTML = '<span>‚è≥</span> Loading...';
                            
                            const loadResponse = await fetch('/api/load', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ saveName: selectedSave.saveName })
                            });
                            
                            const loadResult = await loadResponse.json();
                            
                            if (loadResult.success) {
                                alert(`Game loaded successfully!\n\n${loadResult.message}`);
                                window.location.reload();
                            } else {
                                alert(`Load failed: ${loadResult.error}`);
                            }
                        }
                    }
                } catch (error) {
                    alert(`Load failed: ${error.message}`);
                } finally {
                    this.disabled = false;
                    this.innerHTML = '<span>üìÇ</span> Load Game';
                }
            });

            if (newGameBtn) {
            newGameBtn.addEventListener('click', async function() {
                try {
                    const confirmation = confirm('Start a new game? This will clear your current progress.\n\nYou can optionally enter a custom player name and description.');
                    if (!confirmation) return;
                    
                    // Get optional player details
                    const playerName = prompt('Enter your character name (or leave blank for "Adventurer"):') || 'Adventurer';
                    const playerDescription = prompt('Enter your character description (optional):') || 'A brave soul embarking on a new adventure.';
                    
                    this.disabled = true;
                    this.innerHTML = '<span>‚è≥</span> Creating...';
                    
                    const response = await fetch('/api/new-game', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            playerName: playerName,
                            playerDescription: playerDescription
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.innerHTML = '<span>‚úÖ</span> New Game Started!';
                        alert(`New game created successfully!\n\nPlayer: ${result.player.name}\nStarting Location: ${result.startingLocation.name}\n\nYour adventure begins now!`);
                        window.location.reload();
                    } else {
                        this.innerHTML = '<span>‚ùå</span> Failed';
                        alert(`New game creation failed: ${result.error}`);
                    }
                } catch (error) {
                    this.innerHTML = '<span>‚ùå</span> Failed';
                    alert(`New game creation failed: ${error.message}`);
                } finally {
                    setTimeout(() => {
                        this.disabled = false;
                        this.innerHTML = '<span>üÜï</span> New Game';
                    }, 2000);
                }
            });
            }
        }
    </script>
</body>
</html>
